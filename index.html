<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEAL • AI PRO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fabric.js for Text & Image Manipulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Expanded Font Selection for Text Studio -->
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Bangers&family=Creepster&family=Lobster&family=Monoton&family=Oswald:wght@700&family=Pacifico&family=Press+Start+2P&family=Roboto:wght@900&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        :root, html[data-theme="dark"] { /* Dark Mode */
            --bg-primary: #0a0a0a;
            --bg-surface: #111111;
            --text-primary: #e0e0e0;
            --text-secondary: #888888;
            --border-color: #333333;
            --accent-blue: #0D99FF;
            --accent-red: #FF4500;
            --tool-bg: #1a1a1a;
            --tool-hover: #2a2a2a;
            --tool-active: #333333;
        }

        html[data-theme="light"] { /* Light Mode */
            --bg-primary: #f5f5f5;
            --bg-surface: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --border-color: #cccccc;
            --accent-blue: #0077cc;
            --accent-red: #d93000;
            --tool-bg: #e5e5e5;
            --tool-hover: #d4d4d4;
            --tool-active: #c0c0c0;
        }

        html[data-theme="dark-azure"] { /* Dark Azure Theme */
            --bg-primary: #1a202c;
            --bg-surface: #2d3748;
            --text-primary: #e2e8f0;
            --text-secondary: #a0aec0;
            --border-color: #4a5568;
            --accent-blue: #4299e1;
            --accent-red: #e53e3e;
            --tool-bg: #2d3748;
            --tool-hover: #4a5568;
            --tool-active: #2b6cb0;
        }

        body {
            font-family: 'Space Mono', monospace;
            color: var(--text-primary);
            background-color: var(--bg-primary);
            transition: background-color 0.3s, color 0.3s;
        }

        .panel {
            background-color: var(--bg-surface);
            border: 1px solid var(--border-color);
            border-radius: 0;
        }

        .panel-header {
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-weight: 400;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.3em;
        }

        .panel-content {
            padding: 1.25rem;
        }
        
        .form-input {
            background-color: transparent;
            border: none;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 0;
            transition: border-color 0.2s ease;
            padding: 0.5rem 0;
        }
        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: none;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.5rem;
            border-radius: 0;
            font-weight: 400;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.875rem;
        }
        .btn:hover:not(:disabled) {
            background-color: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }
        .btn:disabled {
            color: var(--text-secondary);
            border-color: var(--border-color);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .btn-primary {
            background-color: var(--text-primary);
            color: var(--bg-primary);
            border: 1px solid var(--text-primary);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: transparent;
            color: var(--text-primary);
        }

        .btn.selected {
            background-color: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }
        
        /* Styles for the segmented style mode control */
        .style-mode-btn, .view-mode-btn {
            border: 1px solid transparent;
            transition: all 0.2s;
            background-color: transparent;
            color: var(--text-secondary);
        }
        .style-mode-btn.selected, .view-mode-btn.selected {
            background-color: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
            border-radius: 0 !important;
        }
        .btn-apply-style {
            background-color: var(--accent-blue) !important;
            color: var(--bg-primary) !important;
            border-color: var(--accent-blue) !important;
        }
        .btn-apply-style:hover:not(:disabled) {
            background-color: transparent !important;
            color: var(--accent-blue) !important;
            border-color: var(--accent-blue) !important;
        }

        .style-btn {
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-secondary);
            font-size: 0.875rem;
            padding: 0.5rem 0.25rem 0.5rem 24px; /* Modified padding: space on left for eye icon */
            text-align: center;
            border-radius: 0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: relative;
            display: flex;
            flex-direction: row; /* Horizontal layout */
            align-items: center;
            justify-content: center;
            height: auto; 
            min-height: 48px; /* Reduced height */
            gap: 0; /* Removed gap */
            transition: all 0.2s;
        }
        .style-btn:hover {
            background-color: var(--border-color);
            color: var(--text-primary);
        }
        .style-btn.selected {
            background-color: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }
        /* .style-icon styles removed as icons are removed */
        
        .style-btn span {
            font-size: 0.65rem; /* Smaller text */
            line-height: 1.1;
            flex-grow: 1;
            white-space: normal; /* Allow wrapping */
            word-break: break-word; /* Break long words if screen sinks */
        }

        .custom-style-btn {
            padding-right: 48px; /* More space for delete button */
        }
        .style-thumbnail {
            width: 32px;
            height: 32px;
            object-fit: cover;
            border-radius: 0;
            border: 1px solid var(--border-color);
            margin-bottom: 0;
            margin-right: 0.5rem; /* Added margin for thumbnail */
            flex-shrink: 0;
        }
        
        .remove-style-btn {
            position: absolute;
            top: 50%;
            right: 4px; /* Adjusted position */
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            background-color: var(--accent-red);
            color: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            opacity: 1;
            border: 1px solid var(--border-color);
            z-index: 5;
        }
        
        .view-prompt-btn {
            position: absolute;
            top: 50%;
            left: 2px; /* Moved to Left */
            right: auto;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background-color: transparent;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            opacity: 0.5; 
            border: none;
            z-index: 5;
        }
        .style-btn:hover .view-prompt-btn {
            opacity: 1;
            color: var(--text-primary);
        }


        /* --- Canvas Aspect Ratio Styles --- */
        #imageDisplayArea {
            background-color: var(--bg-primary); 
            position: relative;
            cursor: pointer;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        
        #canvasAspectRatioWrapper {
            height: 0; 
            width: 100%;
            position: relative;
            padding-bottom: 100%; 
        }
        
        #aspectContent {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-primary);
        }
        
        #generatedImage {
            object-fit: contain; 
        }

        .asset-card {
            background-color: transparent;
            border: 1px solid var(--border-color);
            border-radius: 0;
            padding: 0.75rem;
        }
        .asset-image-preview {
            border-radius: 0;
            border: 1px solid var(--border-color);
        }
        
        .modal-backdrop {
            background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(8px);
        }

        body.modal-open {
            overflow: hidden;
            position: fixed; 
            width: 100%;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .simple-loader {
            width: 80px;
            height: 4px;
            background-color: var(--text-primary);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes spinner-spin {
            to { transform: rotate(360deg); }
        }
        .simple-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spinner-spin 1s linear infinite;
        }


        /* Edit Canvas */
        #maskCanvas { cursor: crosshair; }
        9
        #canvasWrapper { 
            border: 1px solid var(--border-color);
            position: relative;
            margin: auto; 
            max-width: 100%;
            max-height: 60vh; 
            width: auto;
            height: auto;
        }
        
        /* Specific canvas handling for Fabric vs Native */
        #canvasWrapper canvas {
            display: block; 
            width: 100%;
            height: 100%;
        }
        
        /* Fabric JS Container override */
        .canvas-container { 
            margin: 0 auto !important;
            background: transparent !important;
        }
        
        /* Theme Toggle */
        #theme-toggle-container {
            border: 1px solid var(--border-color);
        }
        #theme-toggle {
            height: 20px;
            width: 68px;
            position: relative;
        }
        #theme-indicator {
            position: absolute;
            top: 2px;
            left: 2px;
            height: 16px;
            width: 16px;
            background-color: var(--text-primary);
            transition: transform 0.3s ease;
        }

        /* Camera Angle Specific Styles */
        .angle-category {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--accent-blue);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px dashed var(--border-color);
            padding-bottom: 0.25rem;
        }

        .angle-btn-detail {
             font-size: 0.75rem;
             text-align: left;
             padding: 0.5rem 0.75rem;
             border: 1px solid var(--border-color);
             margin-bottom: 0.25rem;
        }
        .angle-btn-detail:hover {
            border-color: var(--text-primary);
        }
        .angle-btn-detail.selected {
            background-color: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .tweak-btn {
             font-size: 0.7rem;
             text-align: center;
             padding: 0.4rem 0.6rem;
             border: 1px solid var(--border-color);
             margin: 2px;
             line-height: 1.2;
        }
        .tweak-btn:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        /* Text Studio Presets */
        .text-preset-btn {
            height: 50px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .text-preset-btn:hover {
            transform: scale(1.05);
            border-color: var(--accent-blue);
        }

        /* FX Grid */
        .fx-grid-btn {
            background-color: var(--bg-surface);
            border: 1px solid var(--border-color);
            height: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        .fx-grid-btn:hover {
            border-color: var(--accent-blue);
        }
        .fx-icon {
            width: 30px;
            height: 30px;
            background-position: center;
            background-size: contain;
            background-repeat: no-repeat;
        }
        .fx-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        /* Ranges */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--text-primary);
            cursor: pointer;
            border-radius: 0;
            margin-top: -6px; 
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: var(--border-color);
        }

        /* --- New Tool UI Styles --- */
        .tool-icon-btn {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            border-left: 3px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
            background-color: transparent;
        }
        .tool-icon-btn:hover {
            background-color: var(--tool-hover);
            color: var(--text-primary);
        }
        .tool-icon-btn.active {
            color: var(--accent-blue);
            background-color: var(--tool-active);
            border-left: 3px solid var(--accent-blue);
        }
        
        /* Layer List Styles */
        .layer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            margin-bottom: 0.25rem;
            background-color: var(--bg-primary);
            cursor: pointer;
            transition: all 0.2s;
        }
        .layer-item:hover {
            border-color: var(--text-secondary);
        }
        .layer-item.selected {
            border-color: var(--accent-blue);
            background-color: var(--tool-bg);
        }
        .layer-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .layer-btn:hover {
            color: var(--text-primary);
            background-color: var(--bg-surface);
        }
        .layer-btn.delete:hover {
            color: var(--accent-red);
        }
        
        /* Scrollbar styling for properties panel */
        #editPropertiesPanel::-webkit-scrollbar {
            width: 6px;
        }
        #editPropertiesPanel::-webkit-scrollbar-track {
            background: var(--bg-surface); 
        }
        #editPropertiesPanel::-webkit-scrollbar-thumb {
            background: var(--border-color); 
        }
        #editPropertiesPanel::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary); 
        }

        /* --- UPDATED: Scrollable Style Container --- */
        #styleContainer {
            max-height: 260px; /* Approx height for 4 rows (12 items in 3 cols) */
            overflow-y: auto;
            padding-right: 4px;
        }
        #styleContainer::-webkit-scrollbar {
            width: 6px;
        }
        #styleContainer::-webkit-scrollbar-track {
            background: var(--bg-surface);
        }
        #styleContainer::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }
        #styleContainer::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
        
        .crop-ratio-btn {
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }
        .crop-ratio-btn:hover, .crop-ratio-btn.active {
            background-color: var(--text-primary);
            color: var(--bg-primary);
        }
        
        /* Highlight specific styles */
        .highlight-unsafe {
            color: var(--accent-red);
            font-weight: 900;
            background-color: rgba(255, 69, 0, 0.1);
            text-shadow: 0 0 1px var(--accent-red);
        }
        
        .prompt-backdrop {
            z-index: 0;
            pointer-events: none;
        }
        
        /* Re-Angle Card Styles */
        .angle-card {
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .angle-preview {
            width: 100%;
            aspect-ratio: 1;
            background-color: #000;
            object-fit: contain;
            border-bottom: 1px solid var(--border-color);
        }
        .angle-card-header {
            padding: 0.5rem;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-surface);
        }
        .angle-card-actions {
            padding: 0.5rem;
            display: flex;
            gap: 0.25rem;
        }

        /* Enhance Studio Card Styles */
        .enhance-card {
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }
        .enhance-thumb {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }
        .enhance-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        /* --- PROMPT ALIGNMENT FIX V2 --- */
        #promptWrapper {
            position: relative;
            width: 100%;
            height: 128px; /* Fixed height */
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-primary);
        }

        #promptBackdrop, #imagePrompt {
            /* Force exact overlapping geometry */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100% !important;
            height: 100% !important;
            padding: 12px !important;
            margin: 0 !important;
            border: none !important;
            
            /* Typography must match perfectly */
            font-family: 'Space Mono', monospace !important;
            font-size: 14px !important;
            line-height: 1.6 !important;
            letter-spacing: 0 !important;
            
            /* Box Model & Scroll */
            box-sizing: border-box !important;
            overflow-y: scroll !important; /* Force scrollbar on BOTH to match width */
            
            /* Wrapping */
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
        }
        
        #promptBackdrop {
            z-index: 1;
            color: var(--text-primary);
            pointer-events: none;
            background: transparent;
            /* Hide the scrollbar visual on the backdrop so it doesn't look double, 
               but keep the space reserved by 'overflow-y: scroll' */
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
        }
        #promptBackdrop::-webkit-scrollbar {
            width: 8px; /* Match standard scrollbar width */
            background: transparent;
        }
        #promptBackdrop::-webkit-scrollbar-thumb {
            background: transparent;
        }

        #imagePrompt {
            z-index: 2;
            color: transparent !important;
            background: transparent !important;
            caret-color: var(--accent-blue); /* High visibility caret */
            resize: none;
            -webkit-text-fill-color: transparent;
        }
        
        #imagePrompt::selection {
            background-color: rgba(13, 153, 255, 0.2);
            color: transparent;
        }

        /* --- MOBILE OPTIMIZED LAYOUT STYLES --- */
        @media (max-width: 768px) {
            /* GLOBAL COMPACTING */
            .panel-header {
                padding: 0.5rem 0.75rem !important;
                font-size: 0.65rem !important;
            }
            .panel-content {
                padding: 0.75rem !important;
            }
            .btn {
                padding: 0.5rem 0.75rem !important;
                font-size: 0.7rem !important;
                height: auto !important;
                min-height: 2.25rem;
            }
            .form-input, textarea, input, select {
                font-size: 0.75rem !important;
                padding: 0.25rem 0 !important;
            }
            h2, h3, h4, h5 {
                font-size: 0.8rem !important;
                margin-bottom: 0.25rem !important;
            }
            
            /* MODAL SIZING */
            .modal-backdrop .panel {
                width: 96vw !important;
                max-width: 96vw !important;
                max-height: 92vh !important;
            }
            
            /* Specific Tool adjustments */
            .tool-icon-btn {
                width: 32px !important;
                height: 32px !important;
                padding: 4px !important;
            }
            .tool-icon-btn svg {
                width: 16px;
                height: 16px;
            }
            
            #editToolbar {
                padding: 0.25rem !important;
                height: auto !important;
                border-bottom: 1px solid var(--border-color);
                border-right: none !important;
                justify-content: center;
                gap: 0.25rem !important;
            }
            
            /* Order utility overrides for flex column mobile */
            .mobile-order-1 { order: 1 !important; } /* Canvas */
            .mobile-order-2 { order: 2 !important; } /* Toolbar */
            .mobile-order-3 { order: 3 !important; } /* Properties */
            
            /* Canvas takes top portion fixed */
            #editCanvasContainer {
                height: 50vh; /* Reduced height */
                flex-grow: 0 !important;
                border-bottom: 1px solid var(--border-color);
                min-height: 40vh;
            }
            
            /* Properties take remaining space and scroll */
            #editPropertiesPanel {
                flex-grow: 1;
                height: auto;
                max-height: calc(50vh - 45px); /* Adjust based on toolbar height approx */
                padding-bottom: 1rem;
            }
            
            /* Style Grid Compact */
            #styleContainer {
                max-height: 180px !important;
            }
            .style-btn {
                padding: 0.5rem !important;
                font-size: 0.7rem !important;
            }
            .style-thumbnail {
                height: 40px !important;
            }
        }

    </style>
</head>
<body class="p-2 md:p-6"> <!-- Reduced body padding on mobile -->
    <!-- Limit/Fallback Indicator -->
    <div id="limitIndicator" class="fixed top-3 right-3 w-3 h-3 rounded-full bg-red-600 border border-white hidden z-[1000] shadow-sm animate-pulse" title="System limit reached. Using fallback/limited mode."></div>

    <div id="mainContainer" class="max-w-7xl w-full mx-auto">
        <header class="relative text-center mb-8">
            <h1 class="text-2xl md:text-3xl font-bold tracking-[0.3em] uppercase">GEAL • AI PRO</h1>
        </header>

        <main>
            <div id="generationMode" class="flex flex-col lg:grid lg:grid-cols-[400px_1fr] gap-6">
                
                <div class="panel flex-grow lg:order-2 overflow-hidden flex flex-col h-full">
                    <!-- MOVED theme-toggle-wrapper TO HERE -->
                    <div class="panel-header flex justify-between items-center">
                        <span>Canvas</span>
                        <div id="theme-toggle-wrapper" class="flex items-center space-x-2">
                            <span id="theme-label" class="text-xs uppercase tracking-widest hidden sm:inline"></span>
                            <div id="theme-toggle-container" class="p-1">
                                <button id="theme-toggle">
                                    <div id="theme-indicator"></div>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="panel-content flex flex-col flex-grow">
                        
                        <div class="w-full flex-grow flex items-center justify-center p-4 h-full">
                            <div id="imageDisplayArea" class="w-full h-full relative cursor-pointer">
                                <div id="canvasAspectRatioWrapper">
                                    <div id="aspectContent">
                                        
                                        <div id="unifiedLoadingOverlay" class="absolute inset-0 bg-[var(--bg-primary)] bg-opacity-90 flex flex-col items-center justify-center hidden z-20">
                                            <div id="loaderIconContainer" class="mb-4 h-24 w-24 flex items-center justify-center"></div>
                                            <p id="loaderMessage" class="mb-1 text-[var(--text-secondary)]"></p>
                                            <span id="generationTimer" class="text-[10px] font-mono text-[var(--text-secondary)] mb-1 tracking-widest hidden">0.0s</span>
                                            <div class="w-1/2 bg-[var(--border-color)] h-px"><div id="loaderProgressBar" class="bg-[var(--text-primary)] h-px transition-all duration-500" style="width: 0%;"></div></div>
                                        </div>
            
                                        <p id="imagePlaceholder" class="text-[var(--text-secondary)] text-center p-4">Generated image will appear here. Upload an asset or generate one first!</p>
                                        <img id="generatedImage" src="" alt="Generated Image" class="hidden max-h-full max-w-full">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="postImageButtons" class="flex flex-row w-full flex-wrap justify-center gap-2 mt-4 hidden">
                             <button id="cameraViewBtn" class="btn">View</button>
                             <button id="generateViewBtn" class="btn btn-primary hidden">Generate View</button>
                             <button id="describeImageBtn" class="btn">Describe</button>
                             <button id="createStoryBtn" class="btn">Story</button>
                             <button id="editBtn" class="btn">Edit</button>
                             <button id="downloadBtn" class="btn">Download</button>
                        </div>
                        <div id="imageDescriptionContainer" class="mt-4 bg-transparent p-3 border border-[var(--border-color)] hidden"><p id="imageDescription" class="text-[var(--text-secondary)] text-sm"></p></div>
                    
                    </div>
                </div>

                <div class="flex flex-col space-y-6 lg:order-1">
                    <section class="panel">
                        <div class="panel-header flex justify-between items-center">
                            <span>Prompt</span>
                        </div>
                        <div class="panel-content space-y-4">
                            <!-- UPGRADED PROMPT INPUT WITH HIGHLIGHTING -->
                            <div id="promptWrapper">
                                <!-- Backdrop for Highlights -->
                                <div id="promptBackdrop" aria-hidden="true"></div>
                                <!-- Actual Input (Transparent text, Visible Caret) -->
                                <textarea id="imagePrompt" placeholder="Enter a prompt..." spellcheck="false"></textarea>
                            </div>
                            
                            <!-- Safety Suggestion Bar -->
                            <div id="safetySuggestionBar" class="hidden bg-[var(--bg-surface)] border border-red-900/30 p-2 text-xs">
                                <p class="text-[var(--accent-red)] font-bold mb-1 uppercase tracking-wider flex items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="mr-1" viewBox="0 0 16 16"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg>
                                    Unsafe words detected
                                </p>
                                <div id="suggestionContainer" class="flex flex-wrap gap-2"></div>
                            </div>
                            
                            <div class="grid grid-cols-3 gap-2">
                                <button id="refinePromptBtn" class="btn">Refine</button>
                                <button id="generateIdeaBtn" class="btn">Idea</button>
                                <button id="clearPromptBtn" class="btn">Clear</button>
                            </div>
                            
                            <div class="relative">
                                <button id="addAssetTagBtn" class="btn w-full">Add Asset Tag</button>
                                <div id="assetSelectionPopover" class="absolute z-10 top-full mt-1 w-full bg-[var(--bg-surface)] border border-[var(--border-color)] hidden">
                                    <div id="assetTagList" class="p-1 space-y-1"></div>
                                </div>
                            </div>

                            <div id="usageStats" class="text-right text-[0.625rem] leading-tight text-[var(--text-secondary)] tracking-widest pt-2 border-t border-[var(--border-color)] mt-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="h-3 w-3 inline-block mr-1" viewBox="0 0 16 16"><path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/><path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/></svg>
                                (24h 0m / 0g)
                            </div>
                        </div>
                    </section>
                    
                    <button id="generateBtn" class="btn btn-primary w-full h-14">Generate</button>

                    <div class="flex justify-between items-center mb-2 mt-4">
                        <h2 class="text-lg font-bold uppercase tracking-widest">Style Preset</h2>
                         <div class="flex items-center space-x-2">
                            <button id="gealEditorBtn" class="btn !p-2" title="Open GEAL Style Studio">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="h-4 w-4" viewBox="0 0 16 16">
                                    <path d="M6.95.435c.58-.58 1.52-.58 2.1 0l6.515 6.516c.58.58.58 1.519 0 2.098L9.05 15.565c-.58.58-1.519.58-2.098 0L.435 9.05c-.58-.58-.58-1.519 0-2.098L6.95.435z"/>
                                </svg>
                            </button>
                            <button id="importStyleBtn" class="btn !p-2" title="Import style from .geal file">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="h-4 w-4" viewBox="0 0 16 16">
                                    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                                    <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L6.354 8.146a.5.5 0 0 0-.708.708l2 2z"/>
                                </svg>
                            </button>
                            <input type="file" id="importStyleInput" accept=".geal" class="hidden">
                            
                            <button id="exportStyleBtn" class="btn !p-2" title="Export selected style to .geal file" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="h-4 w-4" viewBox="0 0 16 16">
                                    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                                    <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L6.354 4.854a.5.5 0 1 1-.708-.708l2-2z"/>
                                </svg>
                            </button>

                            <button id="addStyleBtn" class="btn !p-2" title="Add style from image(s)">
                               +
                            </button>
                        </div>
                    </div>

                    <div id="styleModeSelector" class="bg-[var(--bg-surface)] p-1 border border-[var(--border-color)] flex w-full">
                        <button data-mode="prompt" id="modePromptBtn" class="style-mode-btn flex-1 p-2 text-xs uppercase tracking-widest" title="Generates a new image using the style's text prompt.">Prompt Style</button>
                        <button data-mode="transfer" id="modeTransferBtn" class="style-mode-btn flex-1 p-2 text-xs uppercase tracking-widest" title="Re-draws the current image using the selected style. (Requires an image)">Image Style</button>
                    </div>

                    <section class="panel !mt-0">
                        <div class="panel-content">
                            <div id="styleContainer" class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                            </div>
                        </div>
                    </section>
                    

                    <section class="panel">
                        <div class="panel-header">Assets</div>
                        <div class="panel-content space-y-4">
                            <input type="file" id="fileInput" accept="image/*" multiple class="hidden">
                             <div class="grid grid-cols-2 gap-2">
                                <button id="uploadAssetBtn" class="btn text-xs w-full">Upload</button>
                                <button id="cameraAssetBtn" class="btn text-xs w-full">Camera</button>
                            </div>
                            <button id="clearAssetsBtn" class="btn w-full text-xs">Clear Assets</button>
                            <div id="uploadedImageContainer" class="grid grid-cols-2 gap-2 pt-2">
                                <p class="col-span-full text-sm text-[var(--text-secondary)]">Upload reference images.</p>
                            </div>
                        </div>
                    </section>
                    
                    <!-- NEW TOOLS PANEL (RENAMED TO STUDIO) -->
                    <section class="panel">
                        <div class="panel-header">STUDIO</div>
                        <div class="panel-content grid grid-cols-2 gap-2 lg:flex lg:flex-col lg:space-y-4">
                            <button id="reAngleToolBtn" class="btn w-full h-full lg:h-auto text-[10px] sm:text-xs lg:text-sm p-2 whitespace-normal leading-tight">Re-Angle Generator</button>
                            <button id="bgRemoverToolBtn" class="btn w-full h-full lg:h-auto text-[10px] sm:text-xs lg:text-sm p-2 whitespace-normal leading-tight">Background Remover</button>
                            <button id="describeToolBtn" class="btn w-full h-full lg:h-auto text-[10px] sm:text-xs lg:text-sm p-2 whitespace-normal leading-tight">Describe Studio</button>
                            <button id="enhanceToolBtn" class="btn w-full h-full lg:h-auto text-[10px] sm:text-xs lg:text-sm p-2 whitespace-normal leading-tight">Enhance Studio</button>
                        </div>
                    </section>
                </div>
            </div>
        </main>
    </div>

    <!-- NEW: Describe Studio Modal -->
    <div id="describeModal" class="fixed inset-0 z-[100] flex items-center justify-center p-2 sm:p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-5xl bg-[var(--bg-primary)] max-h-[95vh] flex flex-col shadow-2xl">
            <div class="panel-header flex justify-between items-center py-2 px-3">
                <span class="text-xs sm:text-sm">Describe Studio</span>
                <div class="flex items-center gap-2 sm:gap-4">
                    <span id="describeTotalEst" class="text-[10px] sm:text-xs text-[var(--accent-blue)] tracking-widest hidden">EST: 0s</span>
                    <button id="closeDescribeBtn" class="text-lg hover:text-[var(--text-primary)] px-2">&times;</button>
                </div>
            </div>
            
            <div class="panel-content flex-grow overflow-y-auto space-y-4 p-3 sm:p-5">
                <!-- Upload Area -->
                <div class="border-b border-[var(--border-color)] pb-3">
                    <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-2">1. Add Images</h4>
                    <div class="grid grid-cols-2 gap-2 sm:flex sm:gap-4">
                        <button id="describeFromCanvasBtn" class="btn h-12 sm:h-16 flex-1 text-[10px] sm:text-xs">
                            <span>+ From Canvas</span>
                        </button>
                        <button id="describeUploadBtn" class="btn btn-primary h-12 sm:h-16 flex-[2] border-dashed text-[10px] sm:text-xs">
                            <span>+ Upload</span>
                        </button>
                        <input type="file" id="describeFileInput" accept="image/*" multiple class="hidden">
                    </div>
                </div>

                <!-- Queue Grid -->
                <div id="describeQueueSection">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-2 gap-2">
                        <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)]">2. Queue</h4>
                        <div class="flex gap-2 w-full sm:w-auto">
                            <button id="startDescribeBtn" class="btn btn-primary text-[10px] sm:text-xs flex-1 sm:flex-none py-2" disabled>Generate All</button>
                            <button id="downloadAllDescriptionsBtn" class="btn text-[10px] sm:text-xs flex-1 sm:flex-none py-2" disabled>Download All</button>
                        </div>
                    </div>
                    
                    <div id="describeGrid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2 sm:gap-3 min-h-[100px]">
                        <p id="describeEmptyMsg" class="col-span-full text-center text-[var(--text-secondary)] py-8 text-[10px] sm:text-sm">No images queued.</p>
                        <!-- Cards injected by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result View Modal (For Descriptions) -->
    <div id="resultViewModal" class="fixed inset-0 z-[120] flex items-center justify-center p-2 sm:p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-2xl bg-[var(--bg-primary)] shadow-2xl flex flex-col max-h-[90vh]">
            <div class="panel-header flex justify-between items-center py-2 px-3">
                <span id="resultViewTitle" class="text-xs sm:text-sm">Analysis Result</span>
                <button id="closeResultViewBtn" class="text-lg hover:text-[var(--text-primary)] px-2">&times;</button>
            </div>
            <div class="panel-content overflow-y-auto p-3 sm:p-5">
                <div class="flex flex-col md:flex-row gap-3 mb-3">
                    <img id="resultViewImage" class="w-full md:w-1/3 h-32 sm:h-40 object-cover border border-[var(--border-color)]">
                    <div class="w-full md:w-2/3 space-y-3">
                        <div>
                            <h5 class="text-[10px] uppercase tracking-widest text-[var(--accent-blue)] mb-1">Description</h5>
                            <p id="resultViewDescription" class="text-[11px] sm:text-sm text-[var(--text-secondary)] bg-[var(--bg-surface)] p-2 h-20 sm:h-24 overflow-y-auto select-text"></p>
                        </div>
                        <div>
                            <h5 class="text-[10px] uppercase tracking-widest text-[var(--accent-blue)] mb-1">Safe Prompt</h5>
                            <div class="relative">
                                <p id="resultViewPrompt" class="text-[11px] sm:text-sm text-[var(--text-primary)] font-mono bg-[var(--bg-surface)] p-2 h-20 sm:h-24 overflow-y-auto select-text"></p>
                                <button id="copyResultPromptBtn" class="absolute top-1 right-1 text-[9px] btn p-1">Copy</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end">
                    <button id="useResultPromptBtn" class="btn btn-primary text-[10px] sm:text-xs">Use Prompt</button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Enhance Studio Modal -->
<!-- ... existing enhance modal ... -->
    <div id="enhanceModal" class="fixed inset-0 z-[100] flex items-center justify-center p-2 sm:p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-5xl bg-[var(--bg-primary)] max-h-[95vh] flex flex-col shadow-2xl">
            <div class="panel-header flex justify-between items-center py-2 px-3">
                <span class="text-xs sm:text-sm">Enhance Studio</span>
                <div class="flex items-center gap-2 sm:gap-4">
                    <span id="enhanceTotalEst" class="text-[10px] sm:text-xs text-[var(--accent-blue)] tracking-widest hidden">EST: 0s</span>
                    <button id="closeEnhanceBtn" class="text-lg hover:text-[var(--text-primary)] px-2">&times;</button>
                </div>
            </div>
            
            <div class="panel-content flex-grow overflow-y-auto space-y-4 p-3 sm:p-5">
                <!-- Upload Area -->
                <div class="border-b border-[var(--border-color)] pb-3">
                    <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-2">1. Batch Upload (Max 20)</h4>
                    <div class="flex gap-2 sm:gap-4">
                        <button id="enhanceUploadBtn" class="btn btn-primary w-full h-12 sm:h-16 border-dashed text-[10px] sm:text-xs">
                            <span>+ Upload Images</span>
                        </button>
                        <input type="file" id="enhanceFileInput" accept="image/*" multiple class="hidden">
                    </div>
                </div>

                <!-- Queue Grid -->
                <div id="enhanceQueueSection">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)]">2. Results</h4>
                        <button id="startEnhanceBtn" class="btn btn-primary text-[10px] sm:text-xs py-2" disabled>Enhance All (8K)</button>
                    </div>
                    
                    <div id="enhanceGrid" class="grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-5 gap-2 sm:gap-3 min-h-[100px]">
                        <p id="enhanceEmptyMsg" class="col-span-full text-center text-[var(--text-secondary)] py-8 text-[10px] sm:text-sm">No images queued.</p>
                        <!-- Cards injected by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Generic Comparison Modal -->
<!-- ... existing comparison modal ... -->
    <div id="comparisonModal" class="fixed inset-0 z-[110] flex items-center justify-center p-2 sm:p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-4xl bg-[var(--bg-primary)] shadow-2xl flex flex-col">
            <div class="panel-header flex justify-between items-center py-2 px-3">
                <span class="text-xs sm:text-sm">Comparison</span>
                <button id="closeComparisonBtn" class="text-lg hover:text-[var(--text-primary)] px-2">&times;</button>
            </div>
            <div class="panel-content p-2 sm:p-4">
                <div class="relative w-full aspect-[4/3] sm:aspect-video bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')] border border-[var(--border-color)] overflow-hidden select-none group" id="universalCompareContainer">
                    <!-- Original (Bottom) -->
                    <img id="compareOriginalImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none">
                    
                    <!-- Result (Top - Clipped) -->
                    <img id="compareResultImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none z-10">
                    
                    <!-- Slider Line -->
                    <div id="compareSliderLine" class="absolute top-0 bottom-0 w-0.5 bg-[var(--accent-blue)] cursor-ew-resize pointer-events-none z-20 shadow-[0_0_10px_rgba(0,0,0,0.5)]" style="left: 50%;">
                         <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-6 h-6 sm:w-8 sm:h-8 bg-[var(--accent-blue)] rounded-full flex items-center justify-center text-white text-[10px] sm:text-xs font-bold shadow-lg">
                             &harr;
                         </div>
                    </div>
                    
                    <!-- Input Range -->
                    <input type="range" id="compareSlider" min="0" max="100" value="50" class="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-30 m-0 p-0 appearance-none">
                    
                    <!-- Labels -->
                    <div class="absolute bottom-2 left-2 bg-black/60 text-white text-[8px] sm:text-[10px] px-2 py-1 rounded pointer-events-none z-20">Enhanced</div>
                    <div class="absolute bottom-2 right-2 bg-black/60 text-white text-[8px] sm:text-[10px] px-2 py-1 rounded pointer-events-none z-20">Original</div>
                </div>
                <div class="flex justify-end mt-2 sm:mt-4">
                     <button id="closeComparisonActionBtn" class="btn text-[10px] sm:text-xs py-2">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Re-Angle Modal -->
<!-- ... existing re-angle modal ... -->
    <div id="reAngleModal" class="fixed inset-0 z-[100] flex items-center justify-center p-2 sm:p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-4xl bg-[var(--bg-primary)] max-h-[95vh] flex flex-col shadow-2xl">
            <div class="panel-header flex justify-between items-center py-2 px-3">
                <span class="text-xs sm:text-sm">Re-Angle Generator</span>
                <button id="closeReAngleBtn" class="text-lg hover:text-[var(--text-primary)] px-2">&times;</button>
            </div>
            
            <div class="panel-content flex-grow overflow-y-auto space-y-4 p-3 sm:p-5">
                <!-- Source Selection -->
                <div class="border-b border-[var(--border-color)] pb-3">
                    <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-2">1. Select Source</h4>
                    <div class="grid grid-cols-3 gap-1 sm:flex sm:gap-4 mb-3">
                        <button class="btn text-[10px] sm:text-xs px-1 sm:flex-1 re-angle-source-btn active" data-source="canvas">Canvas</button>
                        <button class="btn text-[10px] sm:text-xs px-1 sm:flex-1 re-angle-source-btn" data-source="assets">Assets</button>
                        <button class="btn text-[10px] sm:text-xs px-1 sm:flex-1 re-angle-source-btn" data-source="upload">Upload</button>
                    </div>
                    
                    <!-- Source Content Areas -->
                    <div id="reAngleSourceContent">
                        <div id="sourceCanvasArea" class="block">
                            <p class="text-[10px] sm:text-xs text-[var(--text-secondary)] mb-2 text-center">Current Canvas Image</p>
                            <img id="reAnglePreviewCanvas" class="h-24 sm:h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                            <p id="reAngleNoCanvasMsg" class="text-[10px] sm:text-xs text-[var(--accent-red)] text-center">No image on canvas.</p>
                        </div>
                        
                        <div id="sourceAssetsArea" class="hidden">
                             <select id="reAngleAssetSelect" class="form-input w-full text-[10px] sm:text-sm mb-2">
                                 <option value="">Select an asset...</option>
                             </select>
                             <img id="reAnglePreviewAsset" class="h-24 sm:h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                        </div>
                        
                        <div id="sourceUploadArea" class="hidden">
                            <input type="file" id="reAngleUploadInput" accept="image/*" class="hidden">
                            <button id="reAngleUploadBtn" class="btn text-[10px] sm:text-xs mb-2 w-full">Choose File</button>
                            <img id="reAnglePreviewUpload" class="h-24 sm:h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                        </div>
                    </div>
                </div>

                    <!-- Angle Generation Grid -->
                <div>
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3 gap-2">
                        <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)]">2. Angles</h4>
                        
                        <!-- NEW: Mode Selector (Person vs Camera) -->
                        <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 w-full sm:w-auto">
                            <div class="grid grid-cols-2 bg-[var(--bg-surface)] border border-[var(--border-color)] p-1" id="reAngleModeControl">
                                <button class="re-angle-mode-btn p-2 text-center flex items-center justify-center gap-1 transition-colors" data-mode="subject" title="Rotate Subject Only">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
                                    </svg>
                                    <span class="text-[9px] sm:text-[10px] uppercase tracking-wider font-bold">Subject</span>
                                </button>
                                <button class="re-angle-mode-btn p-2 text-center flex items-center justify-center gap-1 transition-colors border-l border-[var(--border-color)]" data-mode="camera" title="Rotate Entire Scene">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M15 12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h1.172a3 3 0 0 0 2.12-.879l.83-.828A1 1 0 0 1 6.827 3h2.344a1 1 0 0 1 .707.293l.828.828A3 3 0 0 0 12.828 5H14a1 1 0 0 1 1 1v6zM2 4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-1.172a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 9.172 2H6.828a2 2 0 0 0-1.414.586l-.828.828A2 2 0 0 1 3.172 4H2z"/>
                                    </svg>
                                    <span class="text-[9px] sm:text-[10px] uppercase tracking-wider font-bold">Scene</span>
                                </button>
                            </div>

                            <div class="flex gap-2">
                                <button id="reAngleGenerateAllBtn" class="btn text-[10px] sm:text-xs flex-1 sm:flex-none">Gen All</button>
                                <button id="reAngleDownloadAllBtn" class="btn text-[10px] sm:text-xs flex-1 sm:flex-none" disabled>DL All</button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="reAngleGrid" class="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-4"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- NEW: Background Remover Modal -->
<!-- ... existing bg remover modal ... -->
    <div id="bgRemoverModal" class="fixed inset-0 z-[100] flex items-center justify-center p-2 sm:p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-4xl bg-[var(--bg-primary)] max-h-[95vh] flex flex-col shadow-2xl">
            <div class="panel-header flex justify-between items-center py-2 px-3">
                <span class="text-xs sm:text-sm">Background Remover</span>
                <button id="closeBgRemoverBtn" class="text-lg hover:text-[var(--text-primary)] px-2">&times;</button>
            </div>
            
            <div class="panel-content flex-grow overflow-y-auto space-y-4 p-3 sm:p-5">
                <!-- Source Selection -->
                <div class="border-b border-[var(--border-color)] pb-3">
                    <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-2">1. Select Source</h4>
                    <div class="grid grid-cols-3 gap-1 sm:flex sm:gap-4 mb-3">
                        <button class="btn text-[10px] sm:text-xs px-1 sm:flex-1 bg-remover-source-btn active" data-source="canvas">Canvas</button>
                        <button class="btn text-[10px] sm:text-xs px-1 sm:flex-1 bg-remover-source-btn" data-source="assets">Assets</button>
                        <button class="btn text-[10px] sm:text-xs px-1 sm:flex-1 bg-remover-source-btn" data-source="upload">Upload</button>
                    </div>
                    
                    <!-- Content Areas -->
                    <div id="bgRemoverSourceContent">
                        <div id="bgSourceCanvasArea" class="block">
                            <img id="bgPreviewCanvas" class="h-24 sm:h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                            <p id="bgNoCanvasMsg" class="text-[10px] sm:text-xs text-[var(--accent-red)] text-center hidden">No image on canvas.</p>
                        </div>
                        <div id="bgSourceAssetsArea" class="hidden">
                             <select id="bgAssetSelect" class="form-input w-full text-[10px] sm:text-sm mb-2">
                                 <option value="">Select an asset...</option>
                             </select>
                             <img id="bgPreviewAsset" class="h-24 sm:h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                        </div>
                        <div id="bgSourceUploadArea" class="hidden">
                            <input type="file" id="bgUploadInput" accept="image/*" class="hidden">
                            <button id="bgUploadBtn" class="btn text-[10px] sm:text-xs mb-2 w-full">Choose File</button>
                            <img id="bgPreviewUpload" class="h-24 sm:h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                        </div>
                    </div>
                    
                    <button id="runBgRemoveBtn" class="btn btn-primary w-full mt-3 text-xs sm:text-sm py-2">Remove Background</button>
                </div>

                <!-- Comparison Area -->
                <div id="bgComparisonSection" class="hidden">
                    <h4 class="text-[10px] sm:text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-2">2. Result</h4>
                    
                    <div class="relative w-full aspect-[4/3] sm:aspect-video bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')] border border-[var(--border-color)] overflow-hidden select-none group" id="bgCompareContainer">
                        <!-- Original (Bottom) -->
                        <img id="bgOriginalImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none">
                        
                        <!-- Result (Top - Clipped) -->
                        <img id="bgResultImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none z-10">
                        
                        <!-- Slider Line -->
                        <div id="bgSliderLine" class="absolute top-0 bottom-0 w-0.5 bg-[var(--accent-blue)] cursor-ew-resize pointer-events-none z-20 shadow-[0_0_10px_rgba(0,0,0,0.5)]" style="left: 50%;">
                             <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-6 h-6 sm:w-8 sm:h-8 bg-[var(--accent-blue)] rounded-full flex items-center justify-center text-white text-[10px] sm:text-xs font-bold shadow-lg">
                                 &harr;
                             </div>
                        </div>
                        
                        <!-- Input Range -->
                        <input type="range" id="bgCompareSlider" min="0" max="100" value="50" class="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-30 m-0 p-0 appearance-none">
                        
                        <!-- Labels -->
                        <div class="absolute bottom-2 left-2 bg-black/60 text-white text-[8px] sm:text-[10px] px-2 py-1 rounded pointer-events-none z-20">Transparent</div>
                        <div class="absolute bottom-2 right-2 bg-black/60 text-white text-[8px] sm:text-[10px] px-2 py-1 rounded pointer-events-none z-20">Original</div>
                    </div>
                    
                    <div class="flex gap-2 mt-3">
                        <button id="downloadBgResultBtn" class="btn btn-primary flex-1 text-[10px] sm:text-xs py-2">Download PNG</button>
                        <button id="saveBgToAssetsBtn" class="btn flex-1 text-[10px] sm:text-xs py-2">Save to Assets</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result View Modal (For Descriptions) -->
    <div id="resultViewModal" class="fixed inset-0 z-[120] flex items-center justify-center p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-2xl bg-[var(--bg-primary)] shadow-2xl flex flex-col max-h-[80vh]">
            <div class="panel-header flex justify-between items-center">
                <span id="resultViewTitle">Analysis Result</span>
                <button id="closeResultViewBtn" class="text-lg hover:text-[var(--text-primary)]">&times;</button>
            </div>
            <div class="panel-content overflow-y-auto">
                <div class="flex flex-col md:flex-row gap-4 mb-4">
                    <img id="resultViewImage" class="w-full md:w-1/3 h-40 object-cover border border-[var(--border-color)]">
                    <div class="w-full md:w-2/3 space-y-4">
                        <div>
                            <h5 class="text-xs uppercase tracking-widest text-[var(--accent-blue)] mb-1">Description</h5>
                            <p id="resultViewDescription" class="text-sm text-[var(--text-secondary)] bg-[var(--bg-surface)] p-2 h-24 overflow-y-auto select-text"></p>
                        </div>
                        <div>
                            <h5 class="text-xs uppercase tracking-widest text-[var(--accent-blue)] mb-1">Safe Prompt</h5>
                            <div class="relative">
                                <p id="resultViewPrompt" class="text-sm text-[var(--text-primary)] font-mono bg-[var(--bg-surface)] p-2 h-24 overflow-y-auto select-text"></p>
                                <button id="copyResultPromptBtn" class="absolute top-1 right-1 text-[10px] btn p-1">Copy</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end">
                    <button id="useResultPromptBtn" class="btn btn-primary text-xs">Use Prompt</button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Enhance Studio Modal -->
<!-- ... existing enhance modal ... -->
    <div id="enhanceModal" class="fixed inset-0 z-[100] flex items-center justify-center p-4 hidden modal-backdrop">
<!-- ... existing content ... -->
        <div class="panel w-full max-w-5xl bg-[var(--bg-primary)] max-h-[90vh] flex flex-col shadow-2xl">
            <div class="panel-header flex justify-between items-center">
                <span>Enhance Studio</span>
                <div class="flex items-center gap-4">
                    <span id="enhanceTotalEst" class="text-xs text-[var(--accent-blue)] tracking-widest hidden">EST: 0s</span>
                    <button id="closeEnhanceBtn" class="text-lg hover:text-[var(--text-primary)]">&times;</button>
                </div>
            </div>
            
            <div class="panel-content flex-grow overflow-y-auto space-y-6">
                <!-- Upload Area -->
                <div class="border-b border-[var(--border-color)] pb-4">
                    <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-3">1. Batch Upload (Max 20)</h4>
                    <div class="flex gap-4">
                        <button id="enhanceUploadBtn" class="btn btn-primary w-full h-16 border-dashed">
                            <span>+ Upload Images to Enhance</span>
                        </button>
                        <input type="file" id="enhanceFileInput" accept="image/*" multiple class="hidden">
                    </div>
                </div>

                <!-- Queue Grid -->
                <div id="enhanceQueueSection">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)]">2. Queue & Results</h4>
                        <button id="startEnhanceBtn" class="btn btn-primary text-xs" disabled>Enhance All (8K)</button>
                    </div>
                    
                    <div id="enhanceGrid" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-3 min-h-[120px]">
                        <p id="enhanceEmptyMsg" class="col-span-full text-center text-[var(--text-secondary)] py-8 text-sm">No images queued. Upload to start.</p>
                        <!-- Cards injected by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Generic Comparison Modal -->
<!-- ... existing comparison modal ... -->
    <div id="comparisonModal" class="fixed inset-0 z-[110] flex items-center justify-center p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-4xl bg-[var(--bg-primary)] shadow-2xl flex flex-col">
            <div class="panel-header flex justify-between items-center">
                <span>Before / After Comparison</span>
                <button id="closeComparisonBtn" class="text-lg hover:text-[var(--text-primary)]">&times;</button>
            </div>
            <div class="panel-content">
                <div class="relative w-full aspect-video bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')] border border-[var(--border-color)] overflow-hidden select-none group" id="universalCompareContainer">
                    <!-- Original (Bottom) -->
                    <img id="compareOriginalImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none">
                    
                    <!-- Result (Top - Clipped) -->
                    <img id="compareResultImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none z-10">
                    
                    <!-- Slider Line -->
                    <div id="compareSliderLine" class="absolute top-0 bottom-0 w-0.5 bg-[var(--accent-blue)] cursor-ew-resize pointer-events-none z-20 shadow-[0_0_10px_rgba(0,0,0,0.5)]" style="left: 50%;">
                         <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-8 h-8 bg-[var(--accent-blue)] rounded-full flex items-center justify-center text-white text-xs font-bold shadow-lg">
                             &harr;
                         </div>
                    </div>
                    
                    <!-- Input Range -->
                    <input type="range" id="compareSlider" min="0" max="100" value="50" class="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-30 m-0 p-0 appearance-none">
                    
                    <!-- Labels -->
                    <div class="absolute bottom-2 left-2 bg-black/60 text-white text-[10px] px-2 py-1 rounded pointer-events-none z-20">Enhanced</div>
                    <div class="absolute bottom-2 right-2 bg-black/60 text-white text-[10px] px-2 py-1 rounded pointer-events-none z-20">Original</div>
                </div>
                <div class="flex justify-end mt-4">
                     <button id="closeComparisonActionBtn" class="btn">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Re-Angle Modal -->
<!-- ... existing re-angle modal ... -->
    <div id="reAngleModal" class="fixed inset-0 z-[100] flex items-center justify-center p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-4xl bg-[var(--bg-primary)] max-h-[90vh] flex flex-col shadow-2xl">
            <div class="panel-header flex justify-between items-center">
                <span>Re-Angle Generator</span>
                <button id="closeReAngleBtn" class="text-lg hover:text-[var(--text-primary)]">&times;</button>
            </div>
            
            <div class="panel-content flex-grow overflow-y-auto space-y-6">
                <!-- Source Selection -->
                <div class="border-b border-[var(--border-color)] pb-4">
                    <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-3">1. Select Source Image</h4>
                    <div class="grid grid-cols-3 gap-2 mb-4">
                        <button class="btn w-full text-[10px] sm:text-xs px-1 re-angle-source-btn active" data-source="canvas">From Canvas</button>
                        <button class="btn w-full text-[10px] sm:text-xs px-1 re-angle-source-btn" data-source="assets">From Assets</button>
                        <button class="btn w-full text-[10px] sm:text-xs px-1 re-angle-source-btn" data-source="upload">Upload</button>
                    </div>
                    
                    <!-- Source Content Areas -->
                    <div id="reAngleSourceContent">
                        <div id="sourceCanvasArea" class="block">
                            <p class="text-xs text-[var(--text-secondary)] mb-2">Using current image from main canvas.</p>
                            <img id="reAnglePreviewCanvas" class="h-32 object-contain border border-[var(--border-color)] hidden">
                            <p id="reAngleNoCanvasMsg" class="text-xs text-[var(--accent-red)]">No image on canvas.</p>
                        </div>
                        
                        <div id="sourceAssetsArea" class="hidden">
                             <select id="reAngleAssetSelect" class="form-input w-full text-sm mb-2">
                                 <option value="">Select an asset...</option>
                             </select>
                             <img id="reAnglePreviewAsset" class="h-32 object-contain border border-[var(--border-color)] hidden">
                        </div>
                        
                        <div id="sourceUploadArea" class="hidden">
                            <input type="file" id="reAngleUploadInput" accept="image/*" class="hidden">
                            <button id="reAngleUploadBtn" class="btn text-xs mb-2">Choose File</button>
                            <img id="reAnglePreviewUpload" class="h-32 object-contain border border-[var(--border-color)] hidden">
                        </div>
                    </div>
                </div>

                    <!-- Angle Generation Grid -->
                <div>
                    <div class="flex flex-col md:flex-row justify-between items-end md:items-center mb-3 gap-2">
                        <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)]">2. Generate Angles</h4>
                        
                        <!-- NEW: Mode Selector (Person vs Camera) -->
                        <div class="flex items-center gap-2">
                            <div class="flex bg-[var(--bg-surface)] border border-[var(--border-color)] p-1" id="reAngleModeControl">
                                <button class="re-angle-mode-btn p-2 px-3 text-[var(--text-secondary)] hover:text-[var(--text-primary)] flex items-center gap-2 transition-colors" data-mode="subject" title="Rotate Subject Only">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
                                    </svg>
                                    <span class="text-[10px] uppercase tracking-wider font-bold">Subject</span>
                                </button>
                                <div class="w-px bg-[var(--border-color)] my-1"></div>
                                <button class="re-angle-mode-btn active p-2 px-3 text-[var(--accent-blue)] bg-[var(--tool-active)] flex items-center gap-2 transition-colors" data-mode="camera" title="Rotate Entire Scene">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M15 12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h1.172a3 3 0 0 0 2.12-.879l.83-.828A1 1 0 0 1 6.827 3h2.344a1 1 0 0 1 .707.293l.828.828A3 3 0 0 0 12.828 5H14a1 1 0 0 1 1 1v6zM2 4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-1.172a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 9.172 2H6.828a2 2 0 0 0-1.414.586l-.828.828A2 2 0 0 1 3.172 4H2z"/>
                                        <path d="M8 11a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5zm0 1a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7zM3 6.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0z"/>
                                    </svg>
                                    <span class="text-[10px] uppercase tracking-wider font-bold text-[var(--text-primary)]">Scene</span>
                                </button>
                            </div>

                            <div class="flex gap-2">
                                <button id="reAngleGenerateAllBtn" class="btn text-xs">Generate All</button>
                                <button id="reAngleDownloadAllBtn" class="btn text-xs" disabled>Download All</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <!-- Angle Cards generated by JS -->
                    </div>
                    <div id="reAngleGrid" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- NEW: Background Remover Modal -->
<!-- ... existing bg remover modal ... -->
    <div id="bgRemoverModal" class="fixed inset-0 z-[100] flex items-center justify-center p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-4xl bg-[var(--bg-primary)] max-h-[90vh] flex flex-col shadow-2xl">
            <div class="panel-header flex justify-between items-center">
                <span>Background Remover</span>
                <button id="closeBgRemoverBtn" class="text-lg hover:text-[var(--text-primary)]">&times;</button>
            </div>
            
            <div class="panel-content flex-grow overflow-y-auto space-y-6">
                <!-- Source Selection -->
                <div class="border-b border-[var(--border-color)] pb-4">
                    <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-3">1. Select Source</h4>
                    <div class="grid grid-cols-3 gap-2 mb-4">
                        <button class="btn w-full text-[10px] sm:text-xs px-1 bg-remover-source-btn active" data-source="canvas">From Canvas</button>
                        <button class="btn w-full text-[10px] sm:text-xs px-1 bg-remover-source-btn" data-source="assets">From Assets</button>
                        <button class="btn w-full text-[10px] sm:text-xs px-1 bg-remover-source-btn" data-source="upload">Upload</button>
                    </div>
                    
                    <!-- Content Areas -->
                    <div id="bgRemoverSourceContent">
                        <div id="bgSourceCanvasArea" class="block">
                            <img id="bgPreviewCanvas" class="h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                            <p id="bgNoCanvasMsg" class="text-xs text-[var(--accent-red)] text-center hidden">No image on canvas.</p>
                        </div>
                        <div id="bgSourceAssetsArea" class="hidden">
                             <select id="bgAssetSelect" class="form-input w-full text-sm mb-2">
                                 <option value="">Select an asset...</option>
                             </select>
                             <img id="bgPreviewAsset" class="h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                        </div>
                        <div id="bgSourceUploadArea" class="hidden">
                            <input type="file" id="bgUploadInput" accept="image/*" class="hidden">
                            <button id="bgUploadBtn" class="btn text-xs mb-2 w-full">Choose File</button>
                            <img id="bgPreviewUpload" class="h-32 object-contain border border-[var(--border-color)] hidden mx-auto">
                        </div>
                    </div>
                    
                    <button id="runBgRemoveBtn" class="btn btn-primary w-full mt-4">Remove Background</button>
                </div>

                <!-- Comparison Area -->
                <div id="bgComparisonSection" class="hidden">
                    <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--accent-blue)] mb-3">2. Result & Comparison</h4>
                    
                    <div class="relative w-full aspect-square md:aspect-video bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiMzMzMiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+')] border border-[var(--border-color)] overflow-hidden select-none group" id="bgCompareContainer">
                        <!-- Original (Bottom) -->
                        <img id="bgOriginalImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none">
                        
                        <!-- Result (Top - Clipped) -->
                        <img id="bgResultImg" class="absolute inset-0 w-full h-full object-contain pointer-events-none z-10">
                        
                        <!-- Slider Line -->
                        <div id="bgSliderLine" class="absolute top-0 bottom-0 w-0.5 bg-[var(--accent-blue)] cursor-ew-resize pointer-events-none z-20 shadow-[0_0_10px_rgba(0,0,0,0.5)]" style="left: 50%;">
                             <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-8 h-8 bg-[var(--accent-blue)] rounded-full flex items-center justify-center text-white text-xs font-bold shadow-lg">
                                 &harr;
                             </div>
                        </div>
                        
                        <!-- Input Range -->
                        <input type="range" id="bgCompareSlider" min="0" max="100" value="50" class="absolute inset-0 w-full h-full opacity-0 cursor-ew-resize z-30 m-0 p-0 appearance-none">
                        
                        <!-- Labels -->
                        <div class="absolute bottom-2 left-2 bg-black/60 text-white text-[10px] px-2 py-1 rounded pointer-events-none z-20">Transparent</div>
                        <div class="absolute bottom-2 right-2 bg-black/60 text-white text-[10px] px-2 py-1 rounded pointer-events-none z-20">Original</div>
                    </div>
                    
                    <div class="flex gap-2 mt-4">
                        <button id="downloadBgResultBtn" class="btn btn-primary flex-1">Download PNG</button>
                        <button id="saveBgToAssetsBtn" class="btn flex-1">Save to Assets</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Safety Alert Modal -->
<!-- ... existing safety modal ... -->
    <div id="safetyAlertModal" class="fixed inset-0 z-[120] flex items-center justify-center p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-md bg-[var(--bg-primary)] shadow-2xl relative border-2 border-[var(--accent-red)]">
            <button id="closeSafetyModal" class="absolute top-2 right-2 text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-xl w-8 h-8 flex items-center justify-center">
                &times;
            </button>
            <div class="panel-header text-[var(--accent-red)] border-red-900/50 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="mr-2" viewBox="0 0 16 16"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg>
                Content Safety Block
            </div>
            <div class="panel-content space-y-4 text-center">
                <h3 class="font-bold text-lg">Generation Failed</h3>
                <p class="text-sm text-[var(--text-secondary)]">The AI system blocked this request due to content safety policies.</p>
                
                <div id="safetyDiagnostics" class="bg-[var(--bg-surface)] p-3 border border-red-900/30 rounded-none text-left hidden">
                    <p class="text-xs uppercase tracking-widest text-[var(--accent-red)] mb-2">Likely Triggers Detected:</p>
                    <ul id="safetyTriggersList" class="list-disc pl-5 text-sm text-[var(--text-primary)]"></ul>
                </div>

                <p class="text-xs text-[var(--text-secondary)] mt-4">Please revise your prompt to be more abstract or use the suggested replacements.</p>
                
                <button id="acknowledgeSafetyBtn" class="btn btn-primary w-full mt-2">I Understand</button>
            </div>
        </div>
    </div>
    
    <!-- Camera Modal -->
    <div id="cameraModal" class="fixed inset-0 z-[120] flex items-center justify-center p-4 hidden modal-backdrop">
        <div class="panel w-full max-w-lg bg-[var(--bg-primary)] shadow-2xl relative">
            <div class="panel-header flex justify-between items-center">
                <span>Camera Capture</span>
                <button id="flipCameraBtn" class="text-xs btn p-2" title="Flip Camera">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 1v2z"/>
                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                    </svg>
                </button>
            </div>
            <div class="panel-content flex flex-col items-center gap-4">
                <div class="relative w-full aspect-square bg-black overflow-hidden border border-[var(--border-color)] group">
                     <video id="cameraVideo" class="w-full h-full object-cover transform scale-x-[-1]" autoplay playsinline></video>
                     <img id="cameraCapturePreview" class="absolute inset-0 w-full h-full object-cover hidden">
                     <div id="cameraFlash" class="absolute inset-0 bg-white opacity-0 pointer-events-none transition-opacity duration-200"></div>
                </div>
                
                <!-- Capture Mode Buttons -->
                <div id="cameraCaptureControls" class="flex gap-2 w-full">
                    <button id="captureCameraBtn" class="btn btn-primary flex-1 h-12">Capture</button>
                    <button id="closeCameraBtn" class="btn flex-1 h-12">Close</button>
                </div>

                <!-- Review Mode Buttons (Hidden by default) -->
                <div id="cameraReviewControls" class="hidden flex gap-2 w-full">
                    <button id="saveCameraBtn" class="btn btn-primary flex-1 h-12">Save to Assets</button>
                    <button id="retakeCameraBtn" class="btn flex-1 h-12">Retake</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Edit Image Modal -->
    <div id="editModal" class="fixed inset-0 z-[100] flex items-center justify-center p-4 hidden modal-backdrop">
<!-- ... existing edit modal content ... -->
        <div class="panel w-full max-w-7xl h-[95vh] flex flex-col bg-[var(--bg-primary)] shadow-2xl overflow-hidden">
            <!-- Header -->
            <div class="panel-header flex justify-between items-center bg-[var(--bg-surface)] border-b border-[var(--border-color)] shrink-0 z-20">
                <span class="font-bold">Edit Image Workspace</span>
                 <div class="flex space-x-2">
                    <button id="cancelEditBtn" class="btn py-1 px-3 text-xs">Cancel</button>
                    <button id="applyChangesBtn" class="btn btn-primary py-1 px-3 text-xs">Apply Changes</button>
                </div>
            </div>
            
            <!-- Main Layout: Toolbar | Properties | Canvas -->
            <div class="panel-content flex-grow overflow-hidden flex flex-col md:flex-row h-full p-0 relative">
                
                <!-- 1. LEFT TOOLBAR (Icons) - MOBILE ORDER 2 -->
                <div id="editToolbar" class="mobile-order-2 order-2 md:order-1 w-full md:w-16 bg-[var(--tool-bg)] border-b md:border-b-0 md:border-r border-[var(--border-color)] flex md:flex-col items-center py-2 md:py-4 gap-2 z-30 shrink-0 overflow-x-auto md:overflow-visible">
                    
                    <button data-tool="inpaint" class="tool-icon-btn active" title="Magic Erase / Inpaint">
                        <!-- Eraser/Bandage Icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414l-3.879-3.879zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/>
                        </svg>
                    </button>
                    
                    <button data-tool="draw" class="tool-icon-btn" title="Creative Draw">
                         <!-- Brush Icon -->
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                           <path d="M15.825.12a.5.5 0 0 1 .132.584c-1.53 3.43-4.743 8.17-7.095 10.64a6.067 6.067 0 0 1-2.373 1.534c-.018.227-.06.538-.169.868-.201.611-.575 1.51-1.22 2.19.278.086.51.2.69.33a.5.5 0 0 1-.58.85c-.001.001-.001.001-.001.001-.119-.086-.339-.23-.656-.477-.735.632-1.764 1.108-2.614 1.108-.558 0-1.077-.241-1.302-.756-.226-.516-.163-1.12.186-1.745C.797 13.596 1.8 12.756 2.457 12c.243-.306.376-.511.458-.621a5.485 5.485 0 0 1 1.534-2.373c2.47-2.352 7.21-5.565 10.64-7.095a.5.5 0 0 1 .584.132zM4.77 11.23c.312.02.658.055 1.05.055 1.17 0 1.99-.59 2.18-1.52.188-.934-.35-2.127-1.205-2.734-.844-.601-1.928-.547-2.632.096-.694.636-.93 1.762-.767 2.766.162.996.84 1.302 1.374 1.337z"/>
                         </svg>
                    </button>

                    <button data-tool="text" class="tool-icon-btn" title="Text Studio">
                        <!-- Type Icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                          <path d="M12.258 3h-8.51l-.083 2.46h.479c.26-1.544.758-1.783 2.693-1.845l.424-.013v7.827c0 .663-.144.82-1.3.923v.52h4.082v-.52c-1.162-.103-1.306-.26-1.306-.923V3.602l.431.013c1.934.062 2.434.301 2.693 1.846h.479L12.258 3z"/>
                        </svg>
                    </button>
                    
                    <button data-tool="filters" class="tool-icon-btn" title="Filters & FX">
                        <!-- Sliders Icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M11.5 2a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM9.05 3a2.5 2.5 0 0 1 4.9 0H16v1h-2.05a2.5 2.5 0 0 1-4.9 0H0V3h9.05zM4.5 7a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM2.05 8a2.5 2.5 0 0 1 4.9 0H16v1H6.95a2.5 2.5 0 0 1-4.9 0H0V8h2.05zm9.45 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm-2.45 1a2.5 2.5 0 0 1 4.9 0H16v1h-2.05a2.5 2.5 0 0 1-4.9 0H0v-1h9.05z"/>
                        </svg>
                    </button>
                    
                     <button data-tool="image" class="tool-icon-btn" title="Add & Edit Images">
                        <!-- Image Icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                            <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/>
                        </svg>
                    </button>

                    <button data-tool="layers" class="tool-icon-btn" title="Layers">
                        <!-- Layers Icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M8.235 1.559a.5.5 0 0 0-.47 0l-7.5 4a.5.5 0 0 0 0 .882L3.188 8 .264 9.559a.5.5 0 0 0 0 .882l7.5 4a.5.5 0 0 0 .47 0l7.5-4a.5.5 0 0 0 0-.882L12.813 8l2.922-1.559a.5.5 0 0 0 0-.882l-7.5-4zm3.515 7.008L14.438 10 8 13.433 1.562 10 4.25 8.567l3.515 1.874a.5.5 0 0 0 .47 0l3.515-1.874zM8 9.433 1.562 6 8 2.567 14.438 6 8 9.433z"/>
                        </svg>
                    </button>
                </div>

                <!-- 2. TOOL PROPERTIES PANEL (Dynamic) - MOBILE ORDER 3 -->
<!-- ... existing properties panel ... -->
                <div id="editPropertiesPanel" class="mobile-order-3 order-3 md:order-2 w-full md:w-80 bg-[var(--bg-surface)] border-b md:border-b-0 md:border-r border-[var(--border-color)] flex flex-col overflow-y-auto shrink-0 z-20 transition-all duration-300">
                    <div class="p-4">
                        
                         <!-- INPAINT CONTROLS -->
                        <div id="inpaintControls" class="space-y-6">
<!-- ... existing controls ... -->
                             <!-- ... existing inpaint controls ... -->
                             <div class="border-b border-[var(--border-color)] pb-2 mb-2">
                                <h3 class="text-sm font-bold uppercase tracking-widest text-[var(--accent-blue)]">Magic Erase / Inpaint</h3>
                            </div>
                            
                            <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Tools</h4>
                                <div class="flex items-center space-x-2 mb-4">
                                     <button id="brushBtn" class="btn flex-1 !p-2" title="Brush">Brush</button>
                                     <button id="eraseBtn" class="btn flex-1 !p-2" title="Eraser">Eraser</button>
                                     <button id="resetBtn" class="btn !p-2 w-10" title="Reset Mask">↺</button>
                                </div>
                                <div>
                                    <label for="brushSizeSlider" class="text-xs uppercase tracking-widest mb-2 block flex justify-between">
                                        <span>Size</span> <span id="brushSizeValue">20</span>
                                    </label>
                                    <input type="range" id="brushSizeSlider" min="5" max="100" value="20" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                </div>
                            </section>

                            <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Generation</h4>
                                <div class="space-y-3">
                                    <div>
                                        <label class="text-xs text-[var(--text-secondary)] block mb-1">Prompt</label>
                                        <textarea id="inpaintingPrompt" rows="3" class="form-input w-full text-sm bg-[var(--bg-primary)] p-2 border border-[var(--border-color)]" placeholder="Describe changes..."></textarea>
                                    </div>
                                    
                                    <div>
                                         <label class="text-xs text-[var(--text-secondary)] block mb-1">Reference (Optional)</label>
                                        <input type="file" id="inpaintingRefFileInput" accept="image/*" class="hidden">
                                        <div class="flex items-center space-x-2">
                                            <button id="uploadInpaintingRefBtn" class="btn flex-1 text-xs py-2">Upload Ref</button>
                                            <button id="removeInpaintingRefBtn" class="btn !p-2 h-8 w-8 hidden text-red-500 border-red-900 hover:bg-red-900 hover:text-white" title="Remove">X</button>
                                        </div>
                                        <img id="inpaintingRefPreview" src="" alt="Reference Preview" class="hidden border border-[var(--border-color)] mt-2 w-full max-h-20 object-cover">
                                    </div>
                                </div>
                            </section>
                        </div>
                        
                        <!-- DRAW CONTROLS (NEW) -->
                        <div id="drawControls" class="hidden space-y-6">
                            <!-- ... existing draw controls ... -->
                            <div class="border-b border-[var(--border-color)] pb-2 mb-2">
                                <h3 class="text-sm font-bold uppercase tracking-widest text-[var(--accent-blue)]">Draw Studio</h3>
                            </div>
                             <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Brush Type</h4>
                                <div class="grid grid-cols-3 gap-2 mb-4">
                                     <button class="btn text-xs p-1 brush-type-btn active" data-type="pencil">Pencil</button>
                                     <button class="btn text-xs p-1 brush-type-btn" data-type="spray">Spray</button>
                                     <button class="btn text-xs p-1 brush-type-btn" data-type="circle">Circle</button>
                                </div>
                                <div class="space-y-3">
                                    <div>
                                        <label class="text-[10px] uppercase tracking-widest text-[var(--text-secondary)]">Color</label>
                                        <input type="color" id="drawColorPicker" class="w-full h-8 bg-transparent border border-[var(--border-color)]" value="#ffffff">
                                    </div>
                                     <div>
                                        <label class="text-[10px] uppercase tracking-widest text-[var(--text-secondary)] flex justify-between">
                                            <span>Width</span> <span id="drawWidthVal">5</span>
                                        </label>
                                        <input type="range" id="drawWidthSlider" min="1" max="100" value="5" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </section>
                        </div>

                        <!-- TEXT CONTROLS -->
                        <div id="textControls" class="hidden space-y-6">
                             <!-- ... existing text controls ... -->
                             <div class="border-b border-[var(--border-color)] pb-2 mb-2">
                                <h3 class="text-sm font-bold uppercase tracking-widest text-[var(--accent-blue)]">Text Studio</h3>
                            </div>

                             <section>
                                <div class="space-y-3">
                                    <div class="flex space-x-2">
                                        <input type="text" id="textInput" class="form-input w-full text-sm" placeholder="Type text...">
                                        <button id="addTextLayerBtn" class="btn btn-primary whitespace-nowrap px-3 text-xs">Add</button>
                                    </div>
                                    <button id="deleteTextBtn" class="btn w-full !text-red-500 border-red-900 hover:bg-red-900 hover:text-white text-xs py-1">Delete Selected</button>
                                </div>
                            </section>
                            
                             <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Typography</h4>
                                <div class="space-y-4">
                                    <div class="space-y-1">
                                        <label class="text-[10px] uppercase tracking-widest text-[var(--text-secondary)]">Font</label>
                                        <select id="fontFamilySelect" class="form-input w-full text-xs bg-[var(--bg-primary)]">
                                            <option value="Space Mono">Space Mono</option>
                                            <option value="Roboto">Roboto</option>
                                            <option value="Oswald">Oswald</option>
                                            <option value="Bangers">Bangers</option>
                                            <option value="Creepster">Creepster</option>
                                            <option value="Lobster">Lobster</option>
                                            <option value="Monoton">Monoton</option>
                                            <option value="Orbitron">Orbitron</option>
                                            <option value="Pacifico">Pacifico</option>
                                            <option value="Press Start 2P">Pixel Art</option>
                                        </select>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <div>
                                            <label class="text-[10px] uppercase tracking-widest text-[var(--text-secondary)]">Fill</label>
                                            <input type="color" id="textColorPicker" class="w-full h-8 bg-transparent border border-[var(--border-color)]" value="#ffffff">
                                        </div>
                                        <div>
                                            <label class="text-[10px] uppercase tracking-widest text-[var(--text-secondary)]">Stroke</label>
                                            <input type="color" id="textStrokePicker" class="w-full h-8 bg-transparent border border-[var(--border-color)]" value="#000000">
                                        </div>
                                    </div>
                                    <div>
                                        <label class="text-[10px] uppercase tracking-widest text-[var(--text-secondary)]">Size</label>
                                        <input type="range" id="textSizeSlider" min="10" max="200" value="40" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </section>

                             <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Effects</h4>
                                <div class="space-y-2">
                                    <div class="flex items-center space-x-2">
                                        <input type="checkbox" id="text3DToggle" class="accent-[var(--accent-blue)]">
                                        <span class="text-xs">3D Depth / Shadow</span>
                                    </div>
                                    <div id="text3DControls" class="space-y-2 opacity-50 pointer-events-none transition-opacity pl-4 border-l border-[var(--border-color)]">
                                        <input type="color" id="text3DColorPicker" class="w-full h-6 bg-transparent border border-[var(--border-color)]" value="#0D99FF">
                                        <input type="range" id="text3DDepthSlider" min="0" max="20" value="5" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </section>

                            <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Presets</h4>
                                <div class="grid grid-cols-3 gap-2" id="textPresetsContainer">
                                    <!-- Presets injected via JS -->
                                </div>
                            </section>
                        </div>

                        <!-- FILTERS CONTROLS -->
                        <div id="filtersControls" class="hidden space-y-6">
                            <!-- ... existing filters controls ... -->
                            <div class="border-b border-[var(--border-color)] pb-2 mb-2">
                                <h3 class="text-sm font-bold uppercase tracking-widest text-[var(--accent-blue)]">Filters & FX</h3>
                            </div>
                            
                            <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Adjustments</h4>
                                <div class="space-y-4">
                                    <div>
                                        <div class="flex justify-between">
                                            <label class="text-[10px] uppercase tracking-widest">Brightness</label>
                                            <span id="brightnessVal" class="text-[10px] text-[var(--text-secondary)]">0</span>
                                        </div>
                                        <input type="range" id="filterBrightness" min="-0.5" max="0.5" step="0.05" value="0" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <div class="flex justify-between">
                                            <label class="text-[10px] uppercase tracking-widest">Contrast</label>
                                            <span id="contrastVal" class="text-[10px] text-[var(--text-secondary)]">0</span>
                                        </div>
                                        <input type="range" id="filterContrast" min="-0.5" max="0.5" step="0.05" value="0" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <div class="flex justify-between">
                                            <label class="text-[10px] uppercase tracking-widest">Saturation</label>
                                            <span id="saturationVal" class="text-[10px] text-[var(--text-secondary)]">0</span>
                                        </div>
                                        <input type="range" id="filterSaturation" min="-1" max="1" step="0.1" value="0" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                    </div>
                                     <div>
                                        <div class="flex justify-between">
                                            <label class="text-[10px] uppercase tracking-widest">Blur</label>
                                            <span id="blurVal" class="text-[10px] text-[var(--text-secondary)]">0</span>
                                        </div>
                                        <input type="range" id="filterBlur" min="0" max="0.5" step="0.01" value="0" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                    </div>
                                     <button id="resetFiltersBtn" class="btn w-full mt-2 text-xs py-1">Reset All</button>
                                </div>
                            </section>

                            <section>
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Procedural FX</h4>
                                <div class="grid grid-cols-3 gap-2" id="fxLibraryGrid">
                                    <!-- FX Buttons injected via JS -->
                                </div>
                                <button id="deleteFxBtn" class="btn w-full !text-red-500 border-red-900 hover:bg-red-900 hover:text-white mt-4 text-xs py-1">Remove Selected FX</button>
                            </section>
                        </div>
                        
                        <!-- IMAGE TOOL CONTROLS -->
                        <div id="imageToolControls" class="hidden space-y-6">
                            <!-- ... existing image tool controls ... -->
                            <div class="border-b border-[var(--border-color)] pb-2 mb-2">
                                <h3 class="text-sm font-bold uppercase tracking-widest text-[var(--accent-blue)]">Image Studio</h3>
                            </div>
                            
                            <section>
                                <button id="uploadLayerImgBtn" class="btn w-full mb-2 text-xs">Upload Image</button>
                                <input type="file" id="layerImgInput" accept="image/*" class="hidden">
                                <p class="text-[10px] text-[var(--text-secondary)] text-center">Supports PNG, JPG, WEBP, SVG</p>
                            </section>
                            
                            <!-- Transform -->
                            <section id="imgTransformSection" class="opacity-50 pointer-events-none transition-opacity">
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Transform</h4>
                                <div class="grid grid-cols-2 gap-2 mb-3">
                                     <button id="imgFlipXBtn" class="btn text-xs">Flip X</button>
                                     <button id="imgFlipYBtn" class="btn text-xs">Flip Y</button>
                                </div>
                                <div class="mb-2">
                                     <label class="text-[10px] uppercase tracking-widest flex justify-between"><span>Rotate</span> <span id="imgRotateVal">0°</span></label>
                                     <input type="range" id="imgRotateSlider" min="-180" max="180" value="0" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                </div>
                                <div>
                                     <label class="text-[10px] uppercase tracking-widest flex justify-between"><span>Opacity</span> <span id="imgOpacityVal">100%</span></label>
                                     <input type="range" id="imgOpacitySlider" min="0" max="100" value="100" class="w-full h-1 bg-[var(--border-color)] appearance-none cursor-pointer">
                                </div>
                            </section>

                            <!-- Crop -->
                            <section id="imgCropSection" class="opacity-50 pointer-events-none transition-opacity">
                                <h4 class="text-xs font-semibold uppercase tracking-widest text-[var(--text-secondary)] mb-3">Crop</h4>
                                <button id="startCropBtn" class="btn w-full mb-2 text-xs">Enter Crop Mode</button>
                                
                                <div id="cropControls" class="hidden space-y-2 border border-[var(--border-color)] p-2 bg-[var(--bg-primary)]">
                                    <p class="text-[10px] text-[var(--text-secondary)]">Adjust the box on canvas</p>
                                    <div class="grid grid-cols-3 gap-1">
                                        <button class="btn text-[10px] p-1 crop-ratio-btn active" data-ratio="free">Free</button>
                                        <button class="btn text-[10px] p-1 crop-ratio-btn" data-ratio="1">1:1</button>
                                        <button class="btn text-[10px] p-1 crop-ratio-btn" data-ratio="1.77">16:9</button>
                                        <button class="btn text-[10px] p-1 crop-ratio-btn" data-ratio="1.33">4:3</button>
                                    </div>
                                    <div class="flex gap-2 mt-2">
                                         <button id="applyCropBtn" class="btn btn-primary flex-1 text-xs">Apply</button>
                                         <button id="cancelCropBtn" class="btn flex-1 text-xs">Cancel</button>
                                    </div>
                                </div>
                            </section>
                        </div>
                        
                        <!-- LAYERS CONTROLS -->
                        <div id="layersControls" class="hidden space-y-6">
                             <!-- ... existing layers controls ... -->
                             <div class="border-b border-[var(--border-color)] pb-2 mb-2 flex justify-between items-center">
                                <h3 class="text-sm font-bold uppercase tracking-widest text-[var(--accent-blue)]">Layers</h3>
                                <span class="text-[10px] text-[var(--text-secondary)]">Drag disabled</span>
                            </div>
                            
                            <div class="space-y-4">
                                <div id="layerListContainer" class="flex flex-col space-y-1">
                                    <!-- Layers injected here -->
                                    <p class="text-xs text-[var(--text-secondary)] text-center py-4">No text or effects added.</p>
                                </div>
                            </div>
                            
                            <div class="pt-4 border-t border-[var(--border-color)]">
                                <p class="text-[10px] text-[var(--text-secondary)] mb-2 uppercase tracking-widest">Quick Arrange</p>
                                <div class="grid grid-cols-2 gap-2">
                                    <button id="layerToFrontBtn" class="btn text-xs py-1">To Front</button>
                                    <button id="layerToBackBtn" class="btn text-xs py-1">To Back</button>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>

                <!-- 3. CANVAS AREA (Maximized) - MOBILE ORDER 1 -->
<!-- ... existing canvas area ... -->
                <div id="editCanvasContainer" class="mobile-order-1 order-1 md:order-3 flex-grow bg-[var(--bg-primary)] relative overflow-hidden flex flex-col z-10">
                    <!-- ... existing canvas code ... -->
                    <!-- Zoom Controls overlay -->
                    <div class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-[var(--bg-surface)] border border-[var(--border-color)] rounded-full px-4 py-1 flex items-center space-x-4 z-50 shadow-lg">
                        <button id="zoomOutBtn" class="text-xl hover:text-[var(--accent-blue)]">-</button>
                        <span id="zoomLevelDisplay" class="text-xs w-8 text-center font-mono">100%</span>
                        <button id="zoomInBtn" class="text-xl hover:text-[var(--accent-blue)]">+</button>
                        <button id="fitViewBtn" class="text-xs hover:text-[var(--accent-blue)] uppercase tracking-wider ml-2">Fit</button>
                    </div>

                     <!-- Info Text -->
                    <div class="absolute bottom-4 left-0 right-0 text-center pointer-events-none z-50">
                        <p id="editInstructionText" class="text-xs text-[var(--text-primary)] bg-[rgba(0,0,0,0.5)] inline-block px-3 py-1 rounded-full backdrop-blur-sm">
                            Inpaint Mode: Draw over the area you want to change.
                        </p>
                    </div>
                    
                    <!-- Canvas Viewport -->
                    <div id="canvasViewport" class="w-full h-full flex justify-center items-center overflow-auto p-8 relative">
                         <div id="canvasWrapper" class="shadow-2xl">
                            <!-- Native Canvases for Inpainting -->
                            <canvas id="imageCanvas" class="hidden"></canvas>
                            <canvas id="maskCanvas" class="absolute top-0 left-0"></canvas>
                            
                            <!-- Fabric Canvas Container -->
                            <div id="fabricCanvasWrapper" class="absolute top-0 left-0 w-full h-full hidden pointer-events-auto origin-top-left transition-transform duration-200 ease-out">
                                 <canvas id="textCanvas"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>
    
    <!-- ... existing other modals (Camera Angle, GEAL Editor, Analyze Style, FullScreen) ... -->
<!-- ... existing modals ... -->
    <!-- Camera Angle Modal -->
    <div id="cameraAngleModal" class="fixed inset-0 z-[100] flex items-center justify-center p-4 hidden modal-backdrop">
        <!-- ... existing camera angle modal ... -->
        <div class="panel w-full max-w-sm bg-[var(--bg-primary)] max-h-[90vh] flex flex-col">
            <div class="panel-header">Select Camera Angle</div>
            <div class="panel-content space-y-4 flex-grow overflow-y-auto">
                <div class="space-y-2">
                    <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--text-secondary)]">View Mode</h4>
                    <div id="viewModeSelector" class="flex w-full border border-[var(--border-color)]">
                        <button data-mode="rotate_image" class="view-mode-btn flex-1 p-2 text-xs uppercase tracking-widest" title="Rotates the entire image and scene.">Rotate Image</button>
                        <button data-mode="rotate_subject" class="view-mode-btn flex-1 p-2 text-xs uppercase tracking-widest" title="Rotates only the subject, locking the background.">Rotate Subject</button>
                    </div>
                </div>
                <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--text-secondary)] border-b border-[var(--border-color)] pb-2">Angle Presets</h4>
                <div id="angleOptionsContainer" class="pr-2 space-y-1"></div>
            </div>
            <div class="panel-content border-t border-[var(--border-color)]">
                <div class="flex justify-end space-x-2">
                    <button id="cancelAngleBtn" class="btn">Cancel</button>
                    <button id="confirmAngleBtn" class="btn btn-primary" disabled>Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- GEAL Style Studio Modal -->
<!-- ... existing geal editor ... -->
    <div id="gealEditorModal" class="fixed inset-0 z-[100] flex items-center justify-center p-4 hidden modal-backdrop">
        <!-- ... existing geal editor modal ... -->
        <div class="panel w-full max-w-2xl bg-[var(--bg-primary)] max-h-[90vh] flex flex-col">
            <div class="panel-header">GEAL Style Studio</div>
            <div class="panel-content flex-grow overflow-y-auto space-y-6">
                <div class="space-y-2">
                    <label for="gealEditorStyleName" class="text-sm font-semibold uppercase tracking-widest text-[var(--text-secondary)]">1. Style Name</label>
                    <input type="text" id="gealEditorStyleName" class="form-input w-full !border !border-[var(--border-color)] !p-2" placeholder="e.g., My Cinematic Style">
                </div>
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label for="gealEditorStylePrompt" class="text-sm font-semibold uppercase tracking-widest text-[var(--text-secondary)]">2. Style Prompt</label>
                        <div class="flex items-center space-x-2">
                            <button id="gealEditorRefineBtn" class="btn !p-2" title="Enhance Prompt with AI">Refine</button>
                            <div id="gealEditorSpinner" class="simple-spinner hidden"></div>
                        </div>
                    </div>
                    <textarea id="gealEditorStylePrompt" rows="6" class="form-input w-full !border !border-[var(--border-color)] !p-2" placeholder="**Photorealistic**, 8k resolution..."></textarea>
                </div>
                <div class="space-y-2">
                    <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--text-secondary)] border-b border-[var(--border-color)] pb-2">3. Prompt Builder</h4>
                    <div id="gealEditorTweakContainer" class="pt-2"></div>
                </div>
            </div>
            <div class="panel-content border-t border-[var(--border-color)]">
                <div class="flex justify-end space-x-2">
                    <button id="gealEditorCancelBtn" class="btn">Cancel</button>
                    <button id="gealEditorSaveBtn" class="btn btn-primary">Save as New Preset</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Analyze Style Modal -->
<!-- ... existing analyze modal ... -->
    <div id="analyzeStyleModal" class="fixed inset-0 z-[100] flex items-center justify-center p-4 hidden modal-backdrop">
        <!-- ... existing analyze modal ... -->
        <div class="panel w-full max-w-2xl bg-[var(--bg-primary)] max-h-[90vh] flex flex-col">
            <div class="panel-header">Analyze Style from Images</div>
            <div class="panel-content flex-grow overflow-y-auto space-y-6">
                <div class="space-y-2">
                    <label for="analyzeStyleName" class="text-sm font-semibold uppercase tracking-widest text-[var(--text-secondary)]">1. Style Name</label>
                    <input type="text" id="analyzeStyleName" class="form-input w-full !border !border-[var(--border-color)] !p-2" placeholder="e.g., My Watercolor Style">
                </div>
                <div class="space-y-2">
                    <h4 class="text-sm font-semibold uppercase tracking-widest text-[var(--text-secondary)]">2. Upload Images (Max 5)</h4>
                    <button id="analyzeStyleUploadBtn" class="btn w-full">Upload Images</button>
                    <input type="file" id="analyzeStyleFileInput" accept="image/*" multiple class="hidden">
                    <div id="analyzeStyleImagePreview" class="grid grid-cols-3 sm:grid-cols-5 gap-2 pt-2 min-h-[80px] border border-dashed border-[var(--border-color)] p-2"></div>
                </div>
            </div>
            <div class="panel-content border-t border-[var(--border-color)]">
                <div class="flex justify-end space-x-2">
                    <button id="analyzeStyleCancelBtn" class="btn">Cancel</button>
                    <button id="analyzeStyleSaveBtn" class="btn btn-primary">Analyze & Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Message Box Modal -->
    <div id="messageBox" class="fixed inset-0 z-[110] flex items-center justify-center p-4 hidden modal-backdrop">
        <!-- ... existing message box ... -->
        <div class="panel w-full max-w-sm text-center bg-[var(--bg-primary)]">
            <div class="panel-header" id="messageTitle">System Message</div>
            <div class="panel-content space-y-4">
                <p id="messageText"></p>
                <input type="text" id="messageBoxInput" class="form-input w-full p-2 hidden">
                <div id="messageBoxButtons" class="flex space-x-2 justify-end"></div>
            </div>
        </div>
    </div>
    
    <!-- Full Screen Modal -->
    <div id="fullScreenModal" class="fixed inset-0 z-[90] flex items-center justify-center p-4 hidden modal-backdrop">
        <!-- ... existing full screen modal ... -->
        <div class="relative max-w-full max-h-full">
            <button id="closeFullScreenModal" class="absolute -top-4 -right-4 text-white text-4xl hover:text-gray-300 transition-colors z-50 p-2">
                &times;
            </button>
            <img id="fullScreenImage" src="" alt="Full Screen Generated Image" class="block max-w-[90vw] max-h-[90vh] object-contain border border-[var(--border-color)]">
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ... [Firebase Config and Auth Code remains unchanged] ...
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let db, auth, userId = null, customStylesUnsubscribe = null;
        
        if (firebaseConfig) {
            try { const app = initializeApp(firebaseConfig); db = getFirestore(app); auth = getAuth(app); } catch (e) { console.error("Firebase initialization failed:", e); }
        }

        // --- NEW: Safe Replacement Dictionary ---
        const unsafeMap = {
            'porn': 'cinematic romance',
            'nude': 'artistic figure study',
            'naked': 'classical sculpture',
            'sex': 'intimacy',
            'blood': 'crimson fluid',
            'kill': 'defeat',
            'gore': 'dark fantasy',
            'nsfw': 'safe for work',
            'xxx': 'rated pg',
            'murder': 'mystery scene',
            'dead': 'fallen',
            'suicide': 'tragedy',
            'breast': 'chest',
            'boobs': 'chest',
            'vagina': 'anatomy',
            'penis': 'anatomy',
            'terrorist': 'villain',
            'bomb': 'device',
            'drug': 'potion',
            'cocaine': 'magic dust',
            'heroin': 'elixir'
        };

        // ... [Main DOMContentLoaded block starts] ...
        document.addEventListener('DOMContentLoaded', async () => {
            const getEl = (id) => document.getElementById(id);
            
            // --- Element Getters ---
            // (Most element getters remain the same, adding new ones for toolbar)
            const generationMode = getEl('generationMode');
            const editModal = getEl('editModal');
            const generateBtn = getEl('generateBtn');
            const imagePrompt = getEl('imagePrompt');
            const promptBackdrop = getEl('promptBackdrop'); // NEW
            const safetySuggestionBar = getEl('safetySuggestionBar'); // NEW
            const suggestionContainer = getEl('suggestionContainer'); // NEW
            const generatedImage = getEl('generatedImage');
            const imagePlaceholder = getEl('imagePlaceholder');
            const downloadBtn = getEl('downloadBtn');
            const editBtn = getEl('editBtn');
            const describeImageBtn = getEl('describeImageBtn');
            const imageDescriptionContainer = getEl('imageDescriptionContainer');
            const imageDescription = getEl('imageDescription');
            const fileInput = getEl('fileInput');
            const uploadAssetBtn = getEl('uploadAssetBtn');
            const uploadedImageContainer = getEl('uploadedImageContainer');
            const cancelEditBtn = getEl('cancelEditBtn');
            const messageBox = getEl('messageBox');
            const messageTitle = getEl('messageTitle');
            const messageText = getEl('messageText');
            const styleContainer = getEl('styleContainer');
            const addAssetTagBtn = getEl('addAssetTagBtn');
            const assetSelectionPopover = getEl('assetSelectionPopover');
            const assetTagList = getEl('assetTagList');
            const addStyleBtn = getEl('addStyleBtn');
            const importStyleBtn = getEl('importStyleBtn');
            const importStyleInput = getEl('importStyleInput');
            const exportStyleBtn = getEl('exportStyleBtn');
            const clearPromptBtn = getEl('clearPromptBtn');
            const refinePromptBtn = getEl('refinePromptBtn');
            const generateIdeaBtn = getEl('generateIdeaBtn');
            const createStoryBtn = getEl('createStoryBtn');
            const fullScreenModal = getEl('fullScreenModal');
            const fullScreenImage = getEl('fullScreenImage');
            const closeFullScreenModal = getEl('closeFullScreenModal');
            const imageDisplayArea = getEl('imageDisplayArea');
            const postImageButtons = getEl('postImageButtons');
            const cameraViewBtn = getEl('cameraViewBtn');
            const generateViewBtn = getEl('generateViewBtn');
            const cameraAngleModal = getEl('cameraAngleModal');
            const angleOptionsContainer = getEl('angleOptionsContainer');
            const confirmAngleBtn = getEl('confirmAngleBtn');
            const cancelAngleBtn = getEl('cancelAngleBtn');
            const unifiedLoadingOverlay = getEl('unifiedLoadingOverlay');
            const loaderIconContainer = getEl('loaderIconContainer');
            const loaderMessage = getEl('loaderMessage');
            const loaderProgressBar = getEl('loaderProgressBar');
            const generationTimer = getEl('generationTimer'); // NEW
            const imageCanvas = getEl('imageCanvas');
            const maskCanvas = getEl('maskCanvas');
            const brushBtn = getEl('brushBtn');
            const eraseBtn = getEl('eraseBtn');
            const resetBtn = getEl('resetBtn');
            const brushSizeSlider = getEl('brushSizeSlider');
            const brushSizeValue = getEl('brushSizeValue');
            const canvasWrapper = getEl('canvasWrapper');
            const applyChangesBtn = getEl('applyChangesBtn');
            const inpaintingPrompt = getEl('inpaintingPrompt');
            const inpaintingRefFileInput = getEl('inpaintingRefFileInput');
            const uploadInpaintingRefBtn = getEl('uploadInpaintingRefBtn');
            const removeInpaintingRefBtn = getEl('removeInpaintingRefBtn');
            const inpaintingRefPreview = getEl('inpaintingRefPreview');
            const clearAssetsBtn = getEl('clearAssetsBtn');
            const canvasAspectRatioWrapper = getEl('canvasAspectRatioWrapper');
            const modePromptBtn = getEl('modePromptBtn');
            const modeTransferBtn = getEl('modeTransferBtn');
            const viewModeSelector = getEl('viewModeSelector');
            const limitIndicator = getEl('limitIndicator');
            
            // --- Safety Modal Elements ---
            const safetyAlertModal = getEl('safetyAlertModal');
            const closeSafetyModal = getEl('closeSafetyModal');
            const acknowledgeSafetyBtn = getEl('acknowledgeSafetyBtn');
            const safetyDiagnostics = getEl('safetyDiagnostics');
            const safetyTriggersList = getEl('safetyTriggersList');

            // --- Edit Modal New Elements (Toolbar) ---
            const toolBtns = document.querySelectorAll('.tool-icon-btn');
            const inpaintControls = getEl('inpaintControls');
            const textControls = getEl('textControls');
            const filtersControls = getEl('filtersControls');
            const imageToolControls = getEl('imageToolControls'); 
            const drawControls = getEl('drawControls'); // NEW
            const layersControls = getEl('layersControls');
            const fabricCanvasWrapper = getEl('fabricCanvasWrapper');
            const editInstructionText = getEl('editInstructionText');
            const textInput = getEl('textInput');
            const addTextLayerBtn = getEl('addTextLayerBtn');
            const fontFamilySelect = getEl('fontFamilySelect');
            const textColorPicker = getEl('textColorPicker');
            const textStrokePicker = getEl('textStrokePicker');
            const textSizeSlider = getEl('textSizeSlider');
            const deleteTextBtn = getEl('deleteTextBtn');
            const textPresetsContainer = getEl('textPresetsContainer');
            const text3DToggle = getEl('text3DToggle');
            const text3DControls = getEl('text3DControls');
            const text3DColorPicker = getEl('text3DColorPicker');
            const text3DDepthSlider = getEl('text3DDepthSlider');

             // --- Filters & FX Elements ---
            const filterBrightness = getEl('filterBrightness');
            const filterContrast = getEl('filterContrast');
            const filterSaturation = getEl('filterSaturation');
            const filterBlur = getEl('filterBlur');
            const resetFiltersBtn = getEl('resetFiltersBtn');
            const fxLibraryGrid = getEl('fxLibraryGrid');
            const deleteFxBtn = getEl('deleteFxBtn');
            
            // --- Image Tool Elements ---
            const uploadLayerImgBtn = getEl('uploadLayerImgBtn');
            const layerImgInput = getEl('layerImgInput');
            const imgTransformSection = getEl('imgTransformSection');
            const imgCropSection = getEl('imgCropSection');
            const imgFlipXBtn = getEl('imgFlipXBtn');
            const imgFlipYBtn = getEl('imgFlipYBtn');
            const imgRotateSlider = getEl('imgRotateSlider');
            const imgRotateVal = getEl('imgRotateVal');
            const imgOpacitySlider = getEl('imgOpacitySlider');
            const imgOpacityVal = getEl('imgOpacityVal');
            const startCropBtn = getEl('startCropBtn');
            const cropControls = getEl('cropControls');
            const applyCropBtn = getEl('applyCropBtn');
            const cancelCropBtn = getEl('cancelCropBtn');
            const cropRatioBtns = document.querySelectorAll('.crop-ratio-btn');
            
            // --- Draw Tool Elements (NEW) ---
            const brushTypeBtns = document.querySelectorAll('.brush-type-btn');
            const drawColorPicker = getEl('drawColorPicker');
            const drawWidthSlider = getEl('drawWidthSlider');
            const drawWidthVal = getEl('drawWidthVal');

            // --- Camera Elements (NEW) ---
            const cameraAssetBtn = getEl('cameraAssetBtn');
            const cameraModal = getEl('cameraModal');
            const cameraVideo = getEl('cameraVideo');
            const cameraCapturePreview = getEl('cameraCapturePreview');
            const cameraFlash = getEl('cameraFlash');
            
            const flipCameraBtn = getEl('flipCameraBtn');
            const captureCameraBtn = getEl('captureCameraBtn');
            const closeCameraBtn = getEl('closeCameraBtn');
            
            const cameraCaptureControls = getEl('cameraCaptureControls');
            const cameraReviewControls = getEl('cameraReviewControls');
            const saveCameraBtn = getEl('saveCameraBtn');
            const retakeCameraBtn = getEl('retakeCameraBtn');

            let cameraStream = null;
            let currentFacingMode = 'user';
            let tempCameraCapture = null;

            // --- Layers Elements ---
            const layerListContainer = getEl('layerListContainer');
            const layerToFrontBtn = getEl('layerToFrontBtn');
            const layerToBackBtn = getEl('layerToBackBtn');

            // --- Edit Modal Zoom Elements ---
            const zoomOutBtn = getEl('zoomOutBtn');
            const zoomInBtn = getEl('zoomInBtn');
            const fitViewBtn = getEl('fitViewBtn');
            const zoomLevelDisplay = getEl('zoomLevelDisplay');
            const canvasViewport = getEl('canvasViewport');

            // --- GEAL Editor Elements ---
            const gealEditorModal = getEl('gealEditorModal');
            const gealEditorBtn = getEl('gealEditorBtn');
            const gealEditorCancelBtn = getEl('gealEditorCancelBtn');
            const gealEditorSaveBtn = getEl('gealEditorSaveBtn');
            const gealEditorStyleName = getEl('gealEditorStyleName');
            const gealEditorStylePrompt = getEl('gealEditorStylePrompt');
            const gealEditorTweakContainer = getEl('gealEditorTweakContainer');
            const gealEditorRefineBtn = getEl('gealEditorRefineBtn');
            const gealEditorSpinner = getEl('gealEditorSpinner');
            
            // --- Analyze Style Modal Elements ---
            const analyzeStyleModal = getEl('analyzeStyleModal');
            const analyzeStyleName = getEl('analyzeStyleName');
            const analyzeStyleUploadBtn = getEl('analyzeStyleUploadBtn');
            const analyzeStyleFileInput = getEl('analyzeStyleFileInput');
            const analyzeStyleImagePreview = getEl('analyzeStyleImagePreview');
            const analyzeStyleCancelBtn = getEl('analyzeStyleCancelBtn');
            const analyzeStyleSaveBtn = getEl('analyzeStyleSaveBtn');
            let tempAnalyzeImages = [];

            // --- Re-Angle Tool Elements ---
            const reAngleToolBtn = getEl('reAngleToolBtn');
            const reAngleModal = getEl('reAngleModal');
            const closeReAngleBtn = getEl('closeReAngleBtn');
            const reAngleSourceBtns = document.querySelectorAll('.re-angle-source-btn');
            const reAngleSourceContent = getEl('reAngleSourceContent');
            const sourceCanvasArea = getEl('sourceCanvasArea');
            const sourceAssetsArea = getEl('sourceAssetsArea');
            const sourceUploadArea = getEl('sourceUploadArea');
            const reAnglePreviewCanvas = getEl('reAnglePreviewCanvas');
            const reAngleNoCanvasMsg = getEl('reAngleNoCanvasMsg');
            const reAngleAssetSelect = getEl('reAngleAssetSelect');
            const reAnglePreviewAsset = getEl('reAnglePreviewAsset');
            const reAngleUploadBtn = getEl('reAngleUploadBtn');
            const reAngleUploadInput = getEl('reAngleUploadInput');
            const reAnglePreviewUpload = getEl('reAnglePreviewUpload');
            const reAngleGrid = getEl('reAngleGrid');
            const reAngleDownloadAllBtn = getEl('reAngleDownloadAllBtn');
            const reAngleGenerateAllBtn = getEl('reAngleGenerateAllBtn'); // ADDED

            // --- Background Remover Tool Elements (NEW) ---
            const bgRemoverToolBtn = getEl('bgRemoverToolBtn');
            const bgRemoverModal = getEl('bgRemoverModal');
            const closeBgRemoverBtn = getEl('closeBgRemoverBtn');
            const bgRemoverSourceBtns = document.querySelectorAll('.bg-remover-source-btn');
            const bgRemoverSourceContent = getEl('bgRemoverSourceContent');
            const bgSourceCanvasArea = getEl('bgSourceCanvasArea');
            const bgSourceAssetsArea = getEl('bgSourceAssetsArea');
            const bgSourceUploadArea = getEl('bgSourceUploadArea');
            const bgPreviewCanvas = getEl('bgPreviewCanvas');
            const bgNoCanvasMsg = getEl('bgNoCanvasMsg');
            const bgAssetSelect = getEl('bgAssetSelect');
            const bgPreviewAsset = getEl('bgPreviewAsset');
            const bgUploadBtn = getEl('bgUploadBtn');
            const bgUploadInput = getEl('bgUploadInput');
            const bgPreviewUpload = getEl('bgPreviewUpload');
            const runBgRemoveBtn = getEl('runBgRemoveBtn');
            const bgComparisonSection = getEl('bgComparisonSection');
            const bgCompareContainer = getEl('bgCompareContainer');
            const bgOriginalImg = getEl('bgOriginalImg');
            const bgResultImg = getEl('bgResultImg');
            const bgCompareSlider = getEl('bgCompareSlider');
            const bgSliderLine = getEl('bgSliderLine');
            const downloadBgResultBtn = getEl('downloadBgResultBtn');
            const saveBgToAssetsBtn = getEl('saveBgToAssetsBtn');
            
            // --- ENHANCE STUDIO ELEMENTS (NEW) ---
            const enhanceToolBtn = getEl('enhanceToolBtn');
            const enhanceModal = getEl('enhanceModal');
            const closeEnhanceBtn = getEl('closeEnhanceBtn');
            const enhanceUploadBtn = getEl('enhanceUploadBtn');
            const enhanceFileInput = getEl('enhanceFileInput');
            const enhanceGrid = getEl('enhanceGrid');
            const enhanceEmptyMsg = getEl('enhanceEmptyMsg');
            const startEnhanceBtn = getEl('startEnhanceBtn');
            const enhanceTotalEst = getEl('enhanceTotalEst');
            let enhanceQueue = [];
            const MAX_ENHANCE_BATCH = 20;

            // --- DESCRIBE STUDIO ELEMENTS (NEW) ---
            const describeToolBtn = getEl('describeToolBtn');
            const describeModal = getEl('describeModal');
            const closeDescribeBtn = getEl('closeDescribeBtn');
            const describeUploadBtn = getEl('describeUploadBtn');
            const describeFromCanvasBtn = getEl('describeFromCanvasBtn');
            const describeFileInput = getEl('describeFileInput');
            const describeGrid = getEl('describeGrid');
            const describeEmptyMsg = getEl('describeEmptyMsg');
            const startDescribeBtn = getEl('startDescribeBtn');
            const downloadAllDescriptionsBtn = getEl('downloadAllDescriptionsBtn');
            
            // Describe Result View Modal
            const resultViewModal = getEl('resultViewModal');
            const closeResultViewBtn = getEl('closeResultViewBtn');
            const resultViewImage = getEl('resultViewImage');
            const resultViewDescription = getEl('resultViewDescription');
            const resultViewPrompt = getEl('resultViewPrompt');
            const copyResultPromptBtn = getEl('copyResultPromptBtn');
            const useResultPromptBtn = getEl('useResultPromptBtn');
            
            let describeQueue = [];

            // --- Comparison Modal Elements (NEW) ---
            const comparisonModal = getEl('comparisonModal');
            const closeComparisonBtn = getEl('closeComparisonBtn');
            const closeComparisonActionBtn = getEl('closeComparisonActionBtn');
            const compareOriginalImg = getEl('compareOriginalImg');
            const compareResultImg = getEl('compareResultImg');
            const compareSlider = getEl('compareSlider');
            const compareSliderLine = getEl('compareSliderLine');

            // BG Remover State
            let bgSourceImage = null;
            let currentBgSource = 'canvas'; 
            let bgResultDataUrl = null;

            // Re-Angle State
            let reAngleSourceImage = null;
            let currentReAngleSource = 'canvas'; // 'canvas', 'assets', 'upload'
            let currentReAngleMode = 'camera'; // Default to Scene (camera) mode

            // UPDATED: Enhanced Angle Library with Accurate Prompts
            const angleTypes = [
                // Perspectives
                { id: 'worm', name: "Worm's Eye", prompt: "Extreme Low Angle (Worm's Eye). Camera placed on the ground looking vertically UP at the subject. 90-degree upward tilt. Subject looks giant and imposing. Ground texture visible in foreground." },
                { id: 'bird', name: "Bird's Eye", prompt: "Extreme High Angle (Bird's Eye). Camera placed high in the sky looking vertically DOWN at the subject. 90-degree downward tilt. Map-like view of the floor/ground." },
                { id: 'top', name: 'Top Down', prompt: 'Direct Overhead View (Plan View). Orthographic top-down perspective. 90-degree angle looking at the crown of the head/top of object.' },
                { id: 'bottom', name: 'Bottom Up', prompt: 'Direct Underneath View. Looking straight up at the soles/base of the subject. 90-degree angle from below.' },
                { id: 'isometric', name: 'Isometric', prompt: 'Isometric View. 30-degree diagonal angle from above. Parallel projection lines (no vanishing point). Video game RPG camera style.' },
                
                // Rotation
                { id: 'front', name: 'Front View', prompt: 'Direct Front View. Perfectly symmetrical composition. Subject facing forward (0 degrees). Eye contact with camera.' },
                { id: 'left', name: 'Left Side', prompt: 'Strict Side Profile (Left). Camera at 90-degree angle to the subject\'s left side. Silhouette distinct.' },
                { id: 'right', name: 'Right Side', prompt: 'Strict Side Profile (Right). Camera at 90-degree angle to the subject\'s right side. Silhouette distinct.' },
                { id: 'rear', name: 'Back View', prompt: 'Direct Rear View. Subject turned 180 degrees away from camera. Viewing the back of the subject.' },
                { id: 'three_quarter', name: '3/4 View', prompt: 'Three-Quarter Angle (45 degrees). Standard portraiture angle. Shows depth and dimension of face/object.' },

                // Framing
                { id: 'wide', name: 'Wide Shot', prompt: 'Wide Angle Lens (16mm). Distant establishing shot. Subject small in the frame, surrounding environment fully visible. Cinematic grandeur.' },
                { id: 'full', name: 'Full Body', prompt: 'Eye-level Full Body Shot. Neutral perspective. Head to toe visible within the frame. Standard focal length (50mm).' },
                { id: 'close', name: 'Close Up', prompt: 'Tight Close-Up. Framing the face or main detail only. 85mm portrait lens. Bokeh background.' },
                { id: 'macro', name: 'Macro', prompt: 'Extreme Macro Detail. 100mm Macro lens. Focus on microscopic textures (skin pores, material weave). Very shallow depth of field.' },
                
                // Artistic/Dynamic
                { id: 'dutch', name: 'Dutch Tilt', prompt: 'Dutch Angle (Canted Angle). Camera tilted diagonally on its roll axis (30-45 degrees). Creates tension, dynamism, and disorientation.' },
                { id: 'fisheye', name: 'Fisheye', prompt: 'Ultra-Wide Fisheye Lens (8mm). Strong barrel distortion. Spherical perspective. Center bulging, edges curved.' },
                { id: 'selfie', name: 'Selfie', prompt: 'Selfie Perspective. Shot from arm\'s length high angle. slight lens distortion on face. Handheld camera aesthetic.' },
                { id: 'ots', name: 'Over Shoulder', prompt: 'Over-the-Shoulder Shot. Camera placed behind a foreground figure (shoulder blurred) looking at the main subject. Cinematic dialogue angle.' }
            ];

            // ... [Usage Stats Elements, Theme Toggle, etc... unchanged] ...
            const usageStatsEl = getEl('usageStats');
            let usageStats = { resetTimestamp: 0, generationCount: 0 };
            let usageStatsInterval = null;

            // ... [Theme Toggle, applyTheme remains unchanged] ...
             // --- Theme Toggle ---
            const themeToggle = getEl('theme-toggle');
            const themeIndicator = getEl('theme-indicator');
            const themeLabel = getEl('theme-label');
            const themes = ['dark', 'light', 'dark-azure'];
            
            function applyTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                localStorage.setItem('theme', theme);
                if(themeLabel) themeLabel.textContent = theme.replace('-', ' ');
                const themeIndex = themes.indexOf(theme); 
                const indicatorPosition = themeIndex * 24; 
                themeIndicator.style.transform = `translateX(${indicatorPosition}px)`;
            }

            themeToggle.addEventListener('click', () => {
                const currentTheme = localStorage.getItem('theme') || 'dark';
                const currentIndex = themes.indexOf(currentTheme);
                const nextIndex = (currentIndex + 1) % themes.length;
                applyTheme(themes[nextIndex]);
            });

            applyTheme(localStorage.getItem('theme') || 'dark');

            // --- Canvas States ---
            let ctx, maskCtx, isDrawing = false;
            let brushSize = parseInt(brushSizeSlider.value, 10);
            let currentTool = 'brush';
            let fabricCanvas = null;
            let currentEditMode = 'inpaint'; 
            let currentZoom = 1;
            
            // Image Tool States
            let activeCropRect = null;
            let isCropping = false;
            let preCropRotation = 0;
            let currentCropRatio = 'free';

            // --- API & App State ---
            const apiKey = ""; 
            const textMultimodalApi = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const imageUrlApi = `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`;
            const imageToImageApi = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
            
            let originalImageData = null, uploadedImages = [], selectedStyleKey = '', customStyles = {};
            let progressInterval = null, genTimerInterval = null, currentCameraAnglePrompt = '', lastGeneratedPrompt = '';
            let inpaintingReferenceData = null;
            let styleMode = 'prompt';
            let currentViewMode = 'rotate_image'; 

            const MAX_ASSETS = 10;
            const generateId = () => Math.random().toString(36).substring(2, 9) + Date.now(); 

            // ... [Style Definitions, Camera Angles, Tweaks - unchanged] ...
             const defaultStyles = {
                'photoreal': { name: 'Hyper Real', prompt: 'Real Life Photograph. Shot on Sony A7R V, 85mm f/1.4 GM lens. 8k UHD. Hyper-realistic skin texture, visible pores, vellus hair. Natural lighting. NOT anime, NOT cartoon, NOT painting, NOT 3d render, NOT illustration. Pure photography, raw file, unedited.' },
                'cinematic': { name: 'Cinematic', prompt: 'Cinematic Movie Shot. Filmed on IMAX 70mm. Arri Alexa camera. Color graded, teal and orange, dramatic chiaroscuro lighting, depth of field, motion blur, film grain. Photorealistic motion picture frame. NOT illustration, NOT animation.' },
                'anime': { name: 'Anime', prompt: 'Japanese Anime Art Style. 2D cel-shaded, flat colors, sharp lines. Ufotable or MAPPA studio style. Vibrant colors, expressive eyes, dynamic composition. NOT photorealistic, NOT 3d render.' },
                'manga': { name: 'Manga', prompt: 'Japanese Manga Page. Black and white ink drawing. Halftone screens, speed lines, high contrast, pen and ink strokes. Traditional comic book aesthetic. NOT color.' },
                'clay': { name: 'Claymation', prompt: 'Stop-Motion Clay Animation. Made of plasticine clay. Visible fingerprints on surface, miniature set, soft studio lighting, tilt-shift effect. Aardman style. Physical textures.' },
                'kids': { name: 'Kids Draw', prompt: 'Child\'s Crayon Drawing. Messy wax crayon textures on rough paper. Simple shapes, bad perspective, scribbles, vibrant primary colors. Kindergarten art.' },
                'famous': { name: 'Fine Art', prompt: 'Classical Oil Painting. Museum masterpiece. Visible brushstrokes, canvas texture, oil paint layers. Renaissance or Impressionist style. Artistic, painterly.' },
                'modern': { name: 'Modern Art', prompt: 'Modern Abstract Art. Bauhaus style. Geometric shapes, flat colors, minimalism, clean lines, avant-garde composition. Graphic design aesthetic.' },
                '3d-render': { name: '3D Render', prompt: '3D CGI Render. Octane Render, Cinema 4D. Raytracing, global illumination, ambient occlusion. Smooth surfaces, subsurface scattering. Pixar or Dreamworks animation style. NOT 2d.' },
                'digital-art': { name: 'Digital Art', prompt: 'Digital Concept Art. Highly detailed, trending on ArtStation. Wacom tablet painting. Fantasy or Sci-Fi illustration. Dynamic lighting, smooth digital brushwork.' },
                'oil-paint': { name: 'Oil Paint', prompt: 'Thick Impasto Oil Painting. Palette knife technique. Heavy texture, 3D paint ridges, rich color blending. Traditional artistic medium.' },
                'watercolor': { name: 'Watercolor', prompt: 'Watercolor Painting. Wet-on-wet technique. Translucent color washes, paper texture visible, bleeding edges, artistic drips. Soft and ethereal.' },
                'cyberpunk': { name: 'Cyberpunk', prompt: 'Cyberpunk Aesthetic. Futuristic city, neon lights, rain, high tech, low life. Pink and cyan color palette. Chromatic aberration, glowing interfaces.' },
                'vintage': { name: 'Vintage', prompt: 'Vintage 1960s Photograph. Kodak Portra film. Heavy film grain, light leaks, dust and scratches, muted colors, soft focus. Retro analog photography.' },
                'pixel': { name: 'Pixel Art', prompt: '16-bit Pixel Art. Retro video game sprite. Low resolution, blocky, limited color palette, dithering. SNES or Genesis style. NOT vector, NOT blurry.' },
                'ghibli': { name: 'Ghibli', prompt: 'Studio Ghibli Animation Style. Hand-painted watercolor backgrounds, cel-shaded characters. Lush greenery, fluffy clouds, nostalgic atmosphere. Hayao Miyazaki aesthetic.' },
                'noir': { name: 'Film Noir', prompt: 'Film Noir Photography. Black and white, high contrast. Chiaroscuro lighting, deep shadows, dramatic silhouettes. 1940s detective movie style.' },
                'fantasy': { name: 'Dark Fantasy', prompt: 'Dark Fantasy Art. Dungeons and Dragons style. Grim atmosphere, magic effects, detailed armor, monsters. Epic scale, dramatic lighting. Oil painting aesthetic.' },
                'pencil': { name: 'Sketch', prompt: 'Graphite Pencil Sketch. Black and white, rough lines, hatching and cross-hatching. Paper texture visible. Hand-drawn artistic study.' },
                'pop-art': { name: 'Pop Art', prompt: 'Pop Art Style. Andy Warhol or Roy Lichtenstein. Bold black outlines, Ben-Day dots, bright flat primary colors. Comic book panel aesthetic.' },
                'minimalist': { name: 'Minimalist', prompt: 'Minimalist Vector Art. Flat design, clean lines, solid colors, negative space. Simple, iconographic, modern.' },
                'scifi': { name: 'Sci-Fi', prompt: 'Sci-Fi Concept Art. Futuristic technology, spaceships, sleek metal, glowing lights. Industrial design, Syd Mead style. High tech.' },
                'horror': { name: 'Horror', prompt: 'Horror Art. Creepy, unsettling, dark, grimy. Psychological horror atmosphere. Distorted, nightmare fuel. Silent Hill aesthetic.' }
            };
            
            const styleTweaks = {
                // ... existing style tweaks ...
                'Core Style': [
                    "**Photorealistic Purity**", "**3D Animated Feature Film Style**", "**Classical Oil Painting**",
                    "**Hyper-Detailed Digital Concept Art**", "**16-bit JRPG Pixel Art**", "**Modern Cinematic Photography**",
                    "**Loose Watercolor Sketch**", "**Neo-Gothic Illustration**", "**High-Contrast Manga Panel**",
                    "**Modern Anime Aesthetic**", "**Classic Studio Ghibli Aesthetic**", "**Intricate Steampunk Concept**",
                    "**Claymation Style**", "**Low-poly 3D Render**", "**Technical Blueprint Drawing**"
                ],
                'Detail & Quality': [
                    "**8k resolution**", "**Hyper-detailed**", "**Pore-level detail**", "**Intricate**",
                    "**Clean cinematic lighting**", "**Museum quality**", "**ArtStation trending**", "**Intense rendering quality**",
                    "**High production value**", "**Meticulously detailed**"
                ],
                'Texture & Effect': [
                    "**Subtle subsurface scattering**", "Heavy impasto", "Visible brushstrokes", "Dithering for shading",
                    "Visible paper texture", "Translucent color overlays", "Heavy use of textures", "Digital screentones",
                    "Polished brass and copper", "Aged leather", "Film grain", "Motion blur", "Anamorphic bokeh",
                    "Minimal chromatic aberration"
                ],
                'Lighting': [ 
                    "Natural light", "High dynamic range", "Volumetric lighting", "Chiaroscuro lighting",
                    "Strong directional backlight", "Focused ambient light", "Studio lighting", "Rim lighting",
                    "Soft, diffused lighting"
                ],
                'Color Palette': [ 
                    "Vibrant and saturated colors", "Muted color scheme", "Restricted color palette", "Sepia and dark metallic",
                    "Monochromatic", "Analogous colors", "Complementary colors", "Pastel palette", "Neon palette", "Warm color temperature"
                ],
                'Contrast & Mood': [ 
                    "High contrast", "Low contrast", "Deep shadows", "Flat lighting", "Moody atmosphere", "Bright and airy",
                    "Soft focus", "Blown-out highlights", "Dramatic silhouette"
                ],
                'Lens & Camera': [
                    "50mm f/1.4 prime lens", "24mm wide-angle lens", "85mm telephoto lens", "14mm lens",
                    "Macro lens", "35mm lens", "Low angle shot", "High angle shot", "Top-down view",
                    "Dutch angle", "Wide screen aspect (2.35:1)"
                ],
                'Transformations & Modifications': [
                    "turn into clay", "make it metallic", "add anime texture skin", "make the hair minimal",
                    "render as a technical blueprint", "shatter into pieces", "turn into chrome", 
                    "convert to neon lines", "make it ( SUBJECT ) only"
                ]
            };
            
            const textPresets = [
                // ... existing text presets ...
                { name: 'Neon', font: 'Orbitron', fill: '#ffffff', stroke: '#00ffff', strokeWidth: 1, shadow: { color: '#00ffff', blur: 20, offsetX: 0, offsetY: 0 }, effect3d: false },
                { name: 'Retro', font: 'Press Start 2P', fill: '#FF00FF', stroke: '#000000', strokeWidth: 0, shadow: { color: '#000000', blur: 0, offsetX: 4, offsetY: 4 }, effect3d: true, depth: 8, depthColor: '#330033' },
                { name: 'Comic', font: 'Bangers', fill: '#FFD700', stroke: '#000000', strokeWidth: 2, shadow: { color: '#000000', blur: 0, offsetX: 5, offsetY: 5 }, effect3d: false },
                { name: 'Elegant', font: 'Lobster', fill: '#FFD700', stroke: '#B8860B', strokeWidth: 0.5, shadow: { color: '#000000', blur: 10, offsetX: 2, offsetY: 2 }, effect3d: false },
                { name: 'Scary', font: 'Creepster', fill: '#880000', stroke: '#000000', strokeWidth: 1, shadow: { color: '#FF0000', blur: 15, offsetX: 0, offsetY: 0 }, effect3d: false },
                { name: 'Clean', font: 'Roboto', fill: '#ffffff', stroke: '#000000', strokeWidth: 0, shadow: { color: 'rgba(0,0,0,0.5)', blur: 4, offsetX: 2, offsetY: 2 }, effect3d: false }
            ];
            
            const fxCategories = [
                // ... existing fx categories ...
                { name: 'Lens Flare', type: 'flare', icon: '☀️' },
                { name: 'Sparkles', type: 'sparkle', icon: '✨' },
                { name: 'Dust', type: 'dust', icon: '🌫️' },
                { name: 'Smoke', type: 'smoke', icon: '☁️' },
                { name: 'Glow Orb', type: 'orb', icon: '🔮' }
            ];

            // ... [Core functions remain unchanged] ...
            function getBaseImageInfo() {
                if (uploadedImages.length > 0) return { dataUrl: uploadedImages[0].dataUrl, isUploaded: true };
                if (originalImageData) return { dataUrl: originalImageData, isUploaded: false };
                return null;
            }

            function updateStyleMode(mode) {
                styleMode = mode;
                [modePromptBtn, modeTransferBtn].forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.mode === mode);
                });
                updateGenerateButton();
            }

            function updateViewMode(mode) {
                currentViewMode = mode;
                viewModeSelector.querySelectorAll('.view-mode-btn').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.mode === mode);
                });
                confirmAngleBtn.disabled = !currentCameraAnglePrompt;
            }

            function updateGenerateButton() {
                const isStyleSelected = !!selectedStyleKey;
                const baseImage = getBaseImageInfo();
                const requiresTransfer = styleMode === 'transfer';
                const canApplyStyle = requiresTransfer && isStyleSelected && baseImage;

                if (canApplyStyle) {
                    generateBtn.textContent = 'Apply Style';
                    generateBtn.classList.add('btn-apply-style');
                    generateBtn.classList.remove('btn-primary');
                    generateBtn.disabled = false;
                } else if (styleMode === 'prompt') {
                    generateBtn.textContent = 'Generate';
                    generateBtn.classList.remove('btn-apply-style');
                    generateBtn.classList.add('btn-primary');
                    generateBtn.disabled = !imagePrompt.value.trim() && !isStyleSelected; 
                } else {
                    generateBtn.textContent = 'Apply Style';
                    generateBtn.classList.remove('btn-apply-style');
                    generateBtn.classList.add('btn-primary');
                    generateBtn.disabled = true;
                }
            }

            function createStyleButton(key, style, isCustom = false) {
                const btn = document.createElement('button');
                btn.className = `style-btn ${key === selectedStyleKey ? 'selected' : ''}`;
                btn.dataset.styleKey = key;

                const viewPromptBtn = document.createElement('div');
                viewPromptBtn.className = 'view-prompt-btn';
                viewPromptBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="h-4 w-4" viewBox="0 0 16 16"><path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.12 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/><path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/></svg>`;
                viewPromptBtn.title = 'View Prompt';
                viewPromptBtn.onclick = (e) => {
                    e.stopPropagation(); 
                    const allStyles = {...defaultStyles, ...customStyles};
                    const styleData = allStyles[key];
                    if (styleData) {
                        showMessageBox(styleData.name, styleData.prompt);
                    }
                };
                
                if (isCustom) {
                    btn.classList.add('custom-style-btn'); 
                    // Icons removed for custom styles unless image data exists (thumbnail)
                    if (style.imageDataUrl) {
                        btn.innerHTML = `<img src="${style.imageDataUrl}" alt="${style.name}" class="style-thumbnail"><span>${style.name}</span>`;
                    } else {
                        btn.innerHTML = `<span>${style.name}</span>`;
                    }
                    
                    const removeBtn = document.createElement('div');
                    removeBtn.className = 'remove-style-btn';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.title = 'Delete this style';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteCustomStyle(key);
                    };
                    btn.appendChild(removeBtn);

                } else {
                    // Default Style Rendering - NO ICON, just text
                    btn.innerHTML = `<span>${style.name}</span>`;
                }
                
                btn.appendChild(viewPromptBtn); // Appended last, but positioned absolute left by CSS

                btn.addEventListener('click', () => {
                    const isNewSelection = selectedStyleKey !== key;
                    selectedStyleKey = isNewSelection ? key : '';
                    
                    renderStyles();
                    updateGenerateButton(); 
                    exportStyleBtn.disabled = !selectedStyleKey;

                    // NEW: Immediate Action for Image Style Mode (Transfer)
                    if (isNewSelection && styleMode === 'transfer') {
                        const baseInfo = getBaseImageInfo();
                        if (!baseInfo) {
                            showMessageBox("Image Required", "Please upload or generate an image first to apply this style.");
                            return;
                        }
                        // Trigger generation immediately
                        handleImageGeneration(imagePrompt.value.trim(), 'style_transfer');
                    }
                });
                styleContainer.appendChild(btn);
            }

            function renderStyles() {
                styleContainer.innerHTML = '';
                Object.keys(defaultStyles).forEach(key => createStyleButton(key, defaultStyles[key], false));
                Object.keys(customStyles).forEach(key => createStyleButton(key, customStyles[key], true));
                exportStyleBtn.disabled = !selectedStyleKey;
            }
            
            // UPDATED: Category Logic for new Angles
            function renderAngleOptions() {
                angleOptionsContainer.innerHTML = '';
                
                // Grouping logic for the updated array-based angleTypes
                const categories = {
                    'Perspectives': ['worm', 'bird', 'top', 'bottom', 'isometric'],
                    'Rotation': ['front', 'left', 'right', 'rear', 'three_quarter'],
                    'Framing': ['wide', 'full', 'close', 'macro'],
                    'Artistic': ['dutch', 'fisheye', 'selfie', 'ots']
                };
                
                // Map flat array to categories for display
                Object.keys(categories).forEach(catName => {
                    // Filter angleTypes that match IDs in this category
                    const matchedAngles = angleTypes.filter(a => categories[catName].includes(a.id));
                    
                    if (matchedAngles.length > 0) {
                        const categoryHeader = document.createElement('h5');
                        categoryHeader.className = 'angle-category';
                        categoryHeader.textContent = catName;
                        angleOptionsContainer.appendChild(categoryHeader);

                        matchedAngles.forEach(angle => {
                            const btn = document.createElement('button');
                            btn.className = `btn w-full angle-btn-detail ${angle.prompt === currentCameraAnglePrompt ? 'selected' : ''}`;
                            btn.dataset.anglePrompt = angle.prompt;
                            btn.textContent = angle.name;
                            
                            btn.addEventListener('click', () => {
                                currentCameraAnglePrompt = angle.prompt;
                                renderAngleOptions(); // Re-render to update selected state
                                confirmAngleBtn.disabled = false;
                            });
                            angleOptionsContainer.appendChild(btn);
                        });
                    }
                });
            }

            function renderGealEditorTweaks() {
                gealEditorTweakContainer.innerHTML = '';
                Object.keys(styleTweaks).forEach(category => {
                    const categoryHeader = document.createElement('h5');
                    categoryHeader.className = 'angle-category';
                    categoryHeader.textContent = category;
                    gealEditorTweakContainer.appendChild(categoryHeader);

                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'flex flex-wrap';
                    
                    styleTweaks[category].forEach(tweak => {
                        const btn = document.createElement('button');
                        btn.className = 'btn tweak-btn';
                        btn.dataset.tweakPrompt = tweak;
                        btn.textContent = tweak.replace(/\*/g, ''); 
                        
                        btn.addEventListener('click', () => {
                            const currentPrompt = gealEditorStylePrompt.value.trim();
                            const separator = (currentPrompt && !currentPrompt.endsWith(',')) ? ', ' : ' ';
                            gealEditorStylePrompt.value = currentPrompt + separator + tweak;
                        });
                        buttonContainer.appendChild(btn);
                    });
                    gealEditorTweakContainer.appendChild(buttonContainer);
                });
            }
            
            function renderTextPresets() {
                textPresetsContainer.innerHTML = '';
                textPresets.forEach(preset => {
                    const btn = document.createElement('div');
                    btn.className = 'text-preset-btn';
                    btn.textContent = 'Abc';
                    btn.style.fontFamily = preset.font;
                    btn.style.color = preset.fill;
                    
                    if (preset.strokeWidth > 0) {
                        btn.style.webkitTextStroke = `${preset.strokeWidth}px ${preset.stroke}`;
                    }
                    if (preset.shadow) {
                        btn.style.textShadow = `${preset.shadow.offsetX}px ${preset.shadow.offsetY}px ${preset.shadow.blur}px ${preset.shadow.color}`;
                    }
                    
                    btn.onclick = () => {
                        const activeObj = fabricCanvas.getActiveObject();
                        if (activeObj && (activeObj.type === 'i-text' || activeObj.type === 'text')) {
                            applyTextPreset(activeObj, preset);
                            fabricCanvas.requestRenderAll();
                            updateTextControlsFromObject(activeObj);
                        } else {
                            addTextToCanvas('Text', preset);
                        }
                    };
                    textPresetsContainer.appendChild(btn);
                });
            }
            
            function renderFxLibrary() {
                fxLibraryGrid.innerHTML = '';
                fxCategories.forEach(cat => {
                    const btn = document.createElement('div');
                    btn.className = 'fx-grid-btn';
                    btn.innerHTML = `
                        <div class="fx-icon flex items-center justify-center text-xl">${cat.icon}</div>
                        <span class="fx-label">${cat.name}</span>
                    `;
                    btn.onclick = () => addEffectToCanvas(cat.type);
                    fxLibraryGrid.appendChild(btn);
                });
            }
            
            // --- NEW: Render Layer List ---
            function renderLayerList() {
                if (!fabricCanvas) return;
                const objects = fabricCanvas.getObjects().slice().reverse(); // Show top items first
                layerListContainer.innerHTML = '';
                
                if (objects.length === 0) {
                    layerListContainer.innerHTML = '<p class="text-xs text-[var(--text-secondary)] text-center py-4">No layers.</p>';
                    return;
                }
                
                const activeObj = fabricCanvas.getActiveObject();
                
                objects.forEach((obj, index) => {
                    // Calculate actual index in Fabric (reversed)
                    const actualIndex = objects.length - 1 - index;
                    
                    const div = document.createElement('div');
                    div.className = `layer-item ${obj === activeObj ? 'selected' : ''}`;
                    
                    // Icon based on type
                    let icon = '❓';
                    let name = 'Layer';
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        icon = '<span class="font-mono font-bold">T</span>';
                        name = obj.text.length > 15 ? obj.text.substring(0,12) + '...' : obj.text;
                    } else if (obj.type === 'image') {
                         icon = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>';
                         name = obj.customName || 'Image Layer';
                    } else if (obj.type === 'path') {
                        icon = '✏️';
                        name = 'Drawing';
                    }
                    
                    div.innerHTML = `
                        <div class="flex items-center gap-2 truncate pointer-events-none">
                           <div class="w-4 h-4 flex items-center justify-center text-[var(--accent-blue)]">${icon}</div>
                           <span class="text-xs truncate max-w-[100px]">${name}</span>
                        </div>
                        <div class="flex gap-1">
                           <button class="layer-btn" title="Up">↑</button>
                           <button class="layer-btn" title="Down">↓</button>
                           <button class="layer-btn delete" title="Delete">×</button>
                        </div>
                    `;
                    
                    // Selection Logic
                    div.onclick = (e) => {
                        if (e.target.tagName !== 'BUTTON') {
                            fabricCanvas.setActiveObject(obj);
                            fabricCanvas.requestRenderAll();
                            renderLayerList(); // Refresh to update highlight
                        }
                    };
                    
                    // Button Logic
                    const btns = div.querySelectorAll('button');
                    // Up (Bring Forward)
                    btns[0].onclick = (e) => {
                        e.stopPropagation();
                        obj.bringForward();
                        fabricCanvas.requestRenderAll();
                        renderLayerList(); // Refresh list order
                    };
                    
                    // Down (Send Backwards)
                    btns[1].onclick = (e) => {
                         e.stopPropagation();
                         obj.sendBackwards();
                         fabricCanvas.requestRenderAll();
                         renderLayerList();
                    };
                    
                    // Delete
                    btns[2].onclick = (e) => {
                        e.stopPropagation();
                        fabricCanvas.remove(obj);
                        fabricCanvas.requestRenderAll();
                        renderLayerList();
                    };

                    layerListContainer.appendChild(div);
                });
            }

            // ... [Usage Stats, Auth, API Utils - UNCHANGED] ...
            function loadUsageStats() {
                let stats;
                try { stats = JSON.parse(localStorage.getItem('gealUsageStats')); } catch (e) {}
                if (stats && Date.now() < stats.resetTimestamp) { usageStats = stats; } 
                else { usageStats = { generationCount: 0, resetTimestamp: Date.now() + 24 * 60 * 60 * 1000 }; localStorage.setItem('gealUsageStats', JSON.stringify(usageStats)); }
                updateUsageDisplay();
                if (usageStatsInterval) clearInterval(usageStatsInterval);
                usageStatsInterval = setInterval(updateUsageDisplay, 1000);
            }
            function updateUsageDisplay() {
                const msRemaining = usageStats.resetTimestamp - Date.now();
                if (msRemaining <= 0) { loadUsageStats(); return; }
                const hours = Math.floor(msRemaining / (1000 * 60 * 60));
                const minutes = Math.floor((msRemaining % (1000 * 60 * 60)) / (1000 * 60));
                if (usageStatsEl) { const icon = usageStatsEl.querySelector('svg').outerHTML; usageStatsEl.innerHTML = `${icon} (${hours}h ${minutes}m / ${usageStats.generationCount}g)`; }
            }
            function incrementGenerationCount() { usageStats.generationCount++; localStorage.setItem('gealUsageStats', JSON.stringify(usageStats)); updateUsageDisplay(); }

            function setupFirestoreListener() {
                if (customStylesUnsubscribe) customStylesUnsubscribe();
                if (!db || !userId) return;
                const stylesCollection = collection(db, `artifacts/${appId}/users/${userId}/custom_styles`);
                customStylesUnsubscribe = onSnapshot(query(stylesCollection), (snapshot) => {
                    customStyles = {};
                    snapshot.forEach(doc => { customStyles[doc.id] = doc.data(); });
                    renderStyles();
                }, (error) => console.error("Error listening to custom styles:", error));
            }
            async function deleteCustomStyle(styleId) {
                if (!db || !userId || !styleId) return;
                try {
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/custom_styles`, styleId);
                    await deleteDoc(docRef);
                    if (selectedStyleKey === styleId) { selectedStyleKey = ''; exportStyleBtn.disabled = true; }
                    updateGenerateButton();
                } catch (error) { showMessageBox("Error", "Could not delete the custom style."); }
            }
            if (auth) {
                onAuthStateChanged(auth, (user) => {
                    if (user) { userId = user.uid; setupFirestoreListener(); } 
                    else { 
                        const signIn = async () => {
                            try { if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) { await signInWithCustomToken(auth, __initial_auth_token); } else { await signInAnonymously(auth); } } catch (error) {}
                        }; signIn(); 
                    }
                });
            }

            async function fetchWithRetry(url, options, retries = 3) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (!response.ok) {
                            if (response.status === 429 || response.status === 503) { if (limitIndicator) limitIndicator.classList.remove('hidden'); }
                            let errorMsg = `API call failed with status: ${response.status}.`;
                            try { const errorBody = await response.json(); errorMsg += ` Message: ${errorBody.error?.message || 'Unknown error'}`; } catch (e) {}
                            throw new Error(errorMsg);
                        }
                        return response;
                    } catch (error) {
                        if (i < retries - 1) { await new Promise(res => setTimeout(res, 1000 * Math.pow(2, i))); } else { throw error; }
                    }
                }
            }

            // ... [Import/Export, MessageBox, Simulation - UNCHANGED] ...
            function handleExportStyle() {
                if (!selectedStyleKey) { showMessageBox("Export Error", "Please select a style to export."); return; }
                const allStyles = {...defaultStyles, ...customStyles};
                const styleToExport = allStyles[selectedStyleKey];
                if (!styleToExport) { showMessageBox("Export Error", "Could not find the selected style data."); return; }
                const exportData = { name: styleToExport.name, prompt: styleToExport.prompt };
                if (customStyles[selectedStyleKey] && styleToExport.imageDataUrl) { exportData.imageDataUrl = styleToExport.imageDataUrl; }
                const fileData = JSON.stringify(exportData, null, 2);
                const blob = new Blob([fileData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url;
                const fileName = styleToExport.name.toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20) || 'style';
                a.download = `${fileName}.geal`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }
            async function handleImportStyle(e) {
                const file = e.target.files[0];
                if (!file) return;
                if (!db || !userId) { showMessageBox("Import Error", "Cannot import style: Database not connected."); e.target.value = ''; return; }
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const fileContent = event.target.result;
                    let importedStyle;
                    try { importedStyle = JSON.parse(fileContent); } catch (err) { showMessageBox("Import Error", "Failed to read file."); return; }
                    if (!importedStyle || typeof importedStyle.name !== 'string' || typeof importedStyle.prompt !== 'string') { showMessageBox("Import Error", "Invalid file format."); return; }
                    const newStyle = { name: importedStyle.name, prompt: importedStyle.prompt };
                    if (importedStyle.imageDataUrl && typeof importedStyle.imageDataUrl === 'string' && importedStyle.imageDataUrl.startsWith('data:image/')) { newStyle.imageDataUrl = importedStyle.imageDataUrl; }
                    try {
                        const docRef = doc(collection(db, `artifacts/${appId}/users/${userId}/custom_styles`));
                        await setDoc(docRef, newStyle);
                        showMessageBox("Success", `Style '${newStyle.name}' imported successfully.`);
                    } catch (error) { showMessageBox("Import Error", "Failed to save the imported style."); }
                };
                reader.readAsText(file); e.target.value = '';
            }
            function showMessageBox(title, message, buttons = [], inputOptions = null) {
                messageTitle.textContent = title; messageText.textContent = message;
                const messageBoxInput = getEl('messageBoxInput'); const messageBoxButtons = getEl('messageBoxButtons');
                messageBoxButtons.innerHTML = ''; messageBoxInput.classList.add('hidden'); messageBoxInput.value = '';
                if (inputOptions) { messageBoxInput.classList.remove('hidden'); messageBoxInput.placeholder = inputOptions.placeholder || ''; messageBoxInput.value = inputOptions.defaultValue || ''; }
                if (buttons.length === 0) buttons.push({ text: 'OK', class: 'btn-primary' });
                buttons.forEach(btnConfig => {
                    const button = document.createElement('button'); button.className = `btn ${btnConfig.class || ''}`; button.textContent = btnConfig.text;
                    button.onclick = () => { if (btnConfig.action) btnConfig.action(inputOptions ? messageBoxInput.value : null); messageBox.classList.add('hidden'); document.body.classList.remove('modal-open'); };
                    messageBoxButtons.appendChild(button);
                });
                messageBox.classList.remove('hidden'); document.body.classList.add('modal-open');
            }
            function startProgressSimulation(mode = 'generate') {
                clearInterval(progressInterval); 
                clearInterval(genTimerInterval);
                unifiedLoadingOverlay.classList.remove('hidden');
                
                let messages = { generate: "Generating...", refine: "Thinking...", idea: "Summoning idea...", story: "Weaving narrative...", view: "Generating new view...", describe: "Analyzing...", inpainting: "Applying changes...", transfer: "Performing deep style transfer...", style_analysis: "Analyzing style...", text_apply: "Compositing text layer...", fx_apply: "Rendering FX layer...", upload: "Uploading Reference...", bg_remove: "Removing background...", describe_batch: "Analyzing Image Batch..." };
                loaderMessage.textContent = messages[mode] || "Processing..."; loaderIconContainer.innerHTML = '<div class="simple-loader"></div>';
                let progress = 0; loaderProgressBar.style.width = '0%';
                
                // Start Fake Progress Bar
                progressInterval = setInterval(() => { progress += Math.random() * 5; if (progress > 95) progress = 95; loaderProgressBar.style.width = `${progress}%`; }, 400);
                
                // Start Real Timer
                generationTimer.classList.remove('hidden');
                generationTimer.textContent = '0.0s';
                let startTime = Date.now();
                genTimerInterval = setInterval(() => {
                    let elapsed = (Date.now() - startTime) / 1000;
                    generationTimer.textContent = elapsed.toFixed(1) + 's';
                }, 100);
            }
            function stopProgressSimulation(isSuccess = false) {
                clearInterval(progressInterval);
                clearInterval(genTimerInterval);
                if (isSuccess) { 
                    loaderProgressBar.style.width = '100%'; 
                    setTimeout(() => { 
                        unifiedLoadingOverlay.classList.add('hidden'); 
                        loaderProgressBar.style.width = '0%'; 
                        generationTimer.classList.add('hidden'); // Hide timer on close
                    }, 500); 
                } 
                else { 
                    unifiedLoadingOverlay.classList.add('hidden'); 
                    loaderProgressBar.style.width = '0%'; 
                    generationTimer.classList.add('hidden');
                }
            }

            const showPostImageControls = () => { if (originalImageData) postImageButtons.classList.remove('hidden'); };
            const hidePostImageControls = () => { postImageButtons.classList.add('hidden'); imageDescriptionContainer.classList.add('hidden'); generateViewBtn.classList.add('hidden'); };
            function getNextAssetTitle() { let nextNum = 1; const existingTitles = new Set(uploadedImages.map(img => img.title)); while (existingTitles.has(`Asset ${nextNum}`)) nextNum++; return `Asset ${nextNum}`; }

            // ... [Render Uploaded, Tags, Handle Image Gen - UNCHANGED] ...
            function renderUploadedImages() {
                uploadedImageContainer.innerHTML = ''; 
                if (uploadedImages.length === 0) { uploadedImageContainer.innerHTML = '<p class="col-span-full text-sm text-[var(--text-secondary)]">Upload reference images.</p>'; }
                uploadAssetBtn.disabled = uploadedImages.length >= MAX_ASSETS;
                uploadedImages.forEach(image => {
                    const assetDiv = document.createElement('div'); assetDiv.className = 'asset-card'; assetDiv.dataset.id = image.id;
                    assetDiv.innerHTML = `<div class="flex justify-between items-center"><span class="text-xs truncate" title="${image.title}">${image.title}</span><div class="flex space-x-2"><button data-id="${image.id}" class="btn-replace text-xs p-1" title="Replace">R</button><button data-id="${image.id}" class="btn-delete text-xs p-1" title="Delete">X</button></div></div><img src="${image.dataUrl}" alt="${image.title}" class="asset-image-preview">`;
                    uploadedImageContainer.appendChild(assetDiv);
                });
                uploadedImageContainer.querySelectorAll('.btn-delete').forEach(button => { button.addEventListener('click', (e) => { const id = e.currentTarget.dataset.id; uploadedImages = uploadedImages.filter(img => img.id !== id); renderUploadedImages(); updateAssetTagList(); updateGenerateButton(); }); });
                uploadedImageContainer.querySelectorAll('.btn-replace').forEach(button => { button.addEventListener('click', (e) => { fileInput.dataset.replaceId = e.currentTarget.dataset.id; fileInput.click(); }); });
                
                // Re-populate asset dropdowns if open
                if (!reAngleModal.classList.contains('hidden')) updateReAngleAssets();
                if (!bgRemoverModal.classList.contains('hidden')) updateBgAssets(); // NEW
                
                updateGenerateButton();
            }
            function updateAssetTagList() {
                 assetTagList.innerHTML = '';
                 if (uploadedImages.length === 0) { assetTagList.innerHTML = '<p class="text-xs text-[var(--text-secondary)] p-2">No assets.</p>'; } 
                 else { uploadedImages.forEach(image => { const tagButton = document.createElement('button'); tagButton.className = 'btn !w-full !justify-start !text-xs'; tagButton.textContent = `[${image.title}]`; tagButton.onclick = () => { 
                     imagePrompt.value += ` [${image.title}]`; 
                     assetSelectionPopover.classList.add('hidden'); 
                     imagePrompt.focus(); 
                     updatePromptHighlights(); // FIX: Update Highlights immediately
                     updateGenerateButton();
                 }; assetTagList.appendChild(tagButton); }); }
            }
            
            // ... [handleImageGeneration] ...
            async function handleImageGeneration(prompt, mode = 'initial', maskBase64 = null, inpaintingRefBase64 = null) {
                // ... existing logic ...
                if (mode !== 'bg_remove' && !prompt && styleMode === 'prompt' && !selectedStyleKey) { return showMessageBox('Input Required', 'Please enter a prompt or select a style preset.'); }
                hidePostImageControls(); imagePlaceholder.classList.remove('hidden'); generatedImage.classList.add('hidden');
                const allStyles = {...defaultStyles, ...customStyles};
                const selectedStyle = selectedStyleKey ? allStyles[selectedStyleKey] : null;
                let payload, apiUrl, base64Data, finalPrompt = prompt;
                const isTransferMode = styleMode === 'transfer'; 
                const isStyleTransferAction = mode === 'style_transfer' || (mode === 'initial' && isTransferMode && selectedStyle);
                const baseImageInfo = isStyleTransferAction ? getBaseImageInfo() : null; 

                if (isTransferMode && (!baseImageInfo || !selectedStyle)) { showMessageBox('Requirement Missing', 'Select a style AND ensure you have a base image.'); stopProgressSimulation(false); return; }
                
                // Show specific loading state if uploading/transferring
                if (uploadedImages.length > 0 || isStyleTransferAction) {
                    startProgressSimulation('upload');
                } else {
                     const simMode = mode === 'view' ? 'view' : (mode === 'inpainting' ? 'inpainting' : (mode === 'bg_remove' ? 'bg_remove' : 'generate')); 
                     startProgressSimulation(simMode);
                }

                if (isStyleTransferAction) {
                    apiUrl = imageToImageApi; 
                    const baseImagePart = { inlineData: { mimeType: "image/png", data: baseImageInfo.dataUrl.split(',')[1] } };
                    let parts = [baseImagePart]; let textPrompt;
                    const contentGuidance = prompt.trim() ? `Use this text prompt for content guidance: "${prompt}".` : "Strictly preserve the subject and composition from the base image.";
                    if (selectedStyle.imageDataUrl) {
                        const styleImagePart = { inlineData: { mimeType: "image/png", data: selectedStyle.imageDataUrl.split(',')[1] } }; parts.push(styleImagePart);
                        textPrompt = `DEEP STYLE TRANSFER (IMAGE). TASK: Redraw Input Image 1.\nSTYLE: Use the exact artistic style of Input Image 2.\nCONTENT: ${contentGuidance}\nRULE: The new image MUST retain the overall composition of Image 1.`; parts.push({ text: textPrompt });
                    } else {
                        textPrompt = `SYSTEM TASK: You are an expert image stylist. TRANSFORM the input image into the style below. \nTARGET STYLE: "${selectedStyle.prompt}"\nCONTEXT: "${prompt}"`; parts.push({ text: textPrompt });
                    }
                    payload = { contents: [{ parts }], generationConfig: { responseModalities: ['IMAGE'] } };
                }
                else {
                    if (styleMode === 'prompt' && selectedStyle && selectedStyle.prompt) { const contentPrompt = prompt ? prompt : "A high-quality image"; finalPrompt = `${contentPrompt}, ${selectedStyle.prompt}`; }
                    
                    if (mode === 'bg_remove') { // NEW LOGIC FOR BACKGROUND REMOVER
                        apiUrl = imageToImageApi;
                        // Use maskBase64 as the SOURCE image argument for convenience here
                        const sourceBase64 = maskBase64; 
                        const bgRemovePrompt = "Generate a PNG image with a cutout of the subject and a transparent background (RGBA). Isolate the main subject completely. The background pixels must be fully transparent (0% opacity). Do NOT render a white, black, or colored background.";
                        
                        const parts = [
                             { text: bgRemovePrompt },
                             { inlineData: { mimeType: "image/png", data: sourceBase64 } }
                        ];
                        payload = { contents: [{ parts }], generationConfig: { responseModalities: ['IMAGE'] } };

                    } else if (mode === 'inpainting') {
                        apiUrl = imageToImageApi;
                        const originalImageBase64 = originalImageData ? originalImageData.split(',')[1] : null;
                        const inpaintingText = `INPAINTING. Fill the masked area (indicated by the non-transparent parts of the second image) with: ${finalPrompt}`;
                        const parts = [ { text: inpaintingText }, { inlineData: { mimeType: "image/png", data: originalImageBase64 } }, { inlineData: { mimeType: "image/png", data: maskBase64 } } ];
                        if (inpaintingRefBase64) { parts.push({ inlineData: { mimeType: "image/png", data: inpaintingRefBase64 } }); }
                        payload = { contents: [{ parts }], generationConfig: { responseModalities: ['IMAGE'] } };
                    } else if (mode === 'view') {
                        apiUrl = imageToImageApi;
                        const originalImageBase64 = originalImageData ? originalImageData.split(',')[1] : null;
                        let viewChangePrompt = "";
                        const anglePromptDetail = currentCameraAnglePrompt;
                        // Use prompt if available, or fallback
                        const promptToUse = lastGeneratedPrompt || "the subject";
                        if (currentViewMode === 'rotate_image') { viewChangePrompt = `NEW CAMERA ANGLE. Re-render the entire scene from this perspective: '${anglePromptDetail}'. Maintain style. Original prompt: '${promptToUse}'.`; } 
                        else if (currentViewMode === 'rotate_subject') { viewChangePrompt = `NEW SUBJECT POSE. Re-render ONLY the main subject from this perspective: '${anglePromptDetail}'. Keep background same. Original prompt: '${promptToUse}'.`; }
                        const parts = [ { text: viewChangePrompt }, { inlineData: { mimeType: "image/png", data: originalImageBase64 } }];
                        payload = { contents: [{ parts }], generationConfig: { responseModalities: ['IMAGE'] } };
                    } else if (uploadedImages.length > 0) {
                        apiUrl = imageToImageApi;
                        const parts = [{ text: `Generate an image based on the attached reference. PROMPT: ${finalPrompt}.` }];
                        uploadedImages.forEach(image => parts.push({ inlineData: { mimeType: "image/png", data: image.dataUrl.split(',')[1] } }));
                        payload = { contents: [{ parts }], generationConfig: { responseModalities: ['IMAGE'] } };
                    } else {
                        apiUrl = imageUrlApi; const ratioTag = ', aspect ratio 1:1';
                        payload = { instances: [{ prompt: finalPrompt + ratioTag }], parameters: { sampleCount: 1 } };
                    }
                }
                
                try {
                    const response = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    const result = await response.json();
                    if (apiUrl === imageUrlApi) { base64Data = result?.predictions?.[0]?.bytesBase64Encoded; } else { base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data; }
                    if (!base64Data) throw new Error(result?.error?.message || "No image data returned from API.");
                    
                    const imageUrl = `data:image/png;base64,${base64Data}`; 

                    // BG Removal Specific Return
                    if (mode === 'bg_remove') {
                        return imageUrl; // Return directly
                    }

                    originalImageData = imageUrl; generatedImage.src = imageUrl;
                    if (mode === 'initial' || mode === 'style_transfer') { lastGeneratedPrompt = finalPrompt; }
                    generatedImage.onload = () => { stopProgressSimulation(true); generatedImage.classList.remove('hidden'); imagePlaceholder.classList.add('hidden'); showPostImageControls(); if (mode === 'inpainting') showMessageBox("Success!", "Inpainting complete."); if (isStyleTransferAction) showMessageBox("Style Applied", `Image Style successfully applied.`); updateGenerateButton(); incrementGenerationCount(); };
                    generatedImage.onerror = () => { throw new Error("Failed to load generated image data."); }
                } catch (error) { 
                    stopProgressSimulation(false); 
                    console.error('Error generating image:', error);
                    
                    if (error.message.includes("No image data returned from API") || error.message.includes("Safety") || error.message.includes("blocked")) {
                        showSafetyAlert(finalPrompt);
                    } else {
                        showMessageBox("Generation Error", `Failed: ${error.message}`); 
                    }
                    if (mode === 'bg_remove') throw error;
                }
            }

            // ... [Other functions: updatePromptHighlights, selectTool, etc] ...

            // --- Background Remover Tool Logic (NEW) ---
            function updateBgAssets() {
                bgAssetSelect.innerHTML = '<option value="">Select an asset...</option>';
                uploadedImages.forEach(img => {
                    const opt = document.createElement('option');
                    opt.value = img.id;
                    opt.textContent = img.title;
                    bgAssetSelect.appendChild(opt);
                });
            }

            function setBgSource(sourceType) {
                // UI Toggle
                bgRemoverSourceBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.source === sourceType);
                });
                
                // Content Toggle
                bgSourceCanvasArea.classList.toggle('hidden', sourceType !== 'canvas');
                bgSourceAssetsArea.classList.toggle('hidden', sourceType !== 'assets');
                bgSourceUploadArea.classList.toggle('hidden', sourceType !== 'upload');
                
                // Reset State
                bgSourceImage = null;
                currentBgSource = sourceType;
                
                if (sourceType === 'canvas') {
                    if (originalImageData) {
                        bgPreviewCanvas.src = originalImageData;
                        bgPreviewCanvas.classList.remove('hidden');
                        bgNoCanvasMsg.classList.add('hidden');
                        bgSourceImage = originalImageData;
                    } else {
                        bgPreviewCanvas.classList.add('hidden');
                        bgNoCanvasMsg.classList.remove('hidden');
                    }
                } else if (sourceType === 'assets') {
                    bgPreviewAsset.classList.add('hidden');
                    bgPreviewAsset.src = '';
                    bgAssetSelect.value = '';
                    updateBgAssets();
                } else if (sourceType === 'upload') {
                     if(bgPreviewUpload.src && !bgPreviewUpload.classList.contains('hidden')) {
                         bgSourceImage = bgPreviewUpload.src;
                     }
                }
            }

            bgRemoverToolBtn.addEventListener('click', () => {
                bgRemoverModal.classList.remove('hidden');
                setBgSource('canvas');
                bgComparisonSection.classList.add('hidden');
            });

            closeBgRemoverBtn.addEventListener('click', () => {
                bgRemoverModal.classList.add('hidden');
            });

            bgRemoverSourceBtns.forEach(btn => {
                btn.addEventListener('click', (e) => setBgSource(e.target.dataset.source));
            });

            bgAssetSelect.addEventListener('change', (e) => {
                const assetId = e.target.value;
                const asset = uploadedImages.find(img => img.id === assetId);
                if (asset) {
                    bgPreviewAsset.src = asset.dataUrl;
                    bgPreviewAsset.classList.remove('hidden');
                    bgSourceImage = asset.dataUrl;
                } else {
                    bgPreviewAsset.classList.add('hidden');
                    bgSourceImage = null;
                }
            });

            bgUploadBtn.addEventListener('click', () => bgUploadInput.click());
            bgUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        bgPreviewUpload.src = evt.target.result;
                        bgPreviewUpload.classList.remove('hidden');
                        bgSourceImage = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = '';
            });

            runBgRemoveBtn.addEventListener('click', async () => {
                if (!bgSourceImage) {
                    showMessageBox("Source Required", "Please select a source image.");
                    return;
                }
                
                bgComparisonSection.classList.add('hidden');
                runBgRemoveBtn.disabled = true;
                
                // Timer Animation (Seconds)
                let seconds = 0;
                runBgRemoveBtn.textContent = "Processing... 0s";
                const bgInterval = setInterval(() => {
                    seconds++;
                    runBgRemoveBtn.textContent = `Processing... ${seconds}s`;
                }, 1000);
                
                try {
                    const resultDataUrl = await handleImageGeneration("", "bg_remove", bgSourceImage.split(',')[1]);
                    
                    if (resultDataUrl) {
                        bgResultDataUrl = resultDataUrl;
                        bgOriginalImg.src = bgSourceImage;
                        bgResultImg.src = bgResultDataUrl;
                        
                        // Reset slider
                        bgCompareSlider.value = 50;
                        bgResultImg.style.clipPath = `polygon(0 0, 50% 0, 50% 100%, 0 100%)`;
                        bgSliderLine.style.left = `50%`;
                        
                        bgComparisonSection.classList.remove('hidden');
                        stopProgressSimulation(true);
                    }
                } catch (error) {
                    console.error(error);
                    stopProgressSimulation(false);
                } finally {
                    clearInterval(bgInterval);
                    runBgRemoveBtn.disabled = false;
                    runBgRemoveBtn.textContent = "Remove Background";
                }
            });

            // Slider Logic
            bgCompareSlider.addEventListener('input', (e) => {
                const val = e.target.value;
                // Clip the Top Image (Result) based on slider
                // If val is 50%, top image is visible 0-50% width
                bgResultImg.style.clipPath = `polygon(0 0, ${val}% 0, ${val}% 100%, 0 100%)`;
                bgSliderLine.style.left = `${val}%`;
            });

            downloadBgResultBtn.addEventListener('click', () => {
                if (bgResultDataUrl) {
                    const a = document.createElement('a');
                    a.href = bgResultDataUrl;
                    a.download = 'geal-bg-removed.png';
                    a.click();
                }
            });

            saveBgToAssetsBtn.addEventListener('click', () => {
                if (bgResultDataUrl) {
                    if (uploadedImages.length < MAX_ASSETS) {
                        uploadedImages.push({ id: generateId(), dataUrl: bgResultDataUrl, title: getNextAssetTitle() + " (Trans)" });
                        renderUploadedImages();
                        updateAssetTagList();
                        updateGenerateButton();
                        showMessageBox("Success", "Saved to Assets.");
                    } else {
                        showMessageBox("Limit Reached", `Max ${MAX_ASSETS} assets.`);
                    }
                }
            });


            // --- NEW: Safety Logic & Highlighting (Existing functions) ---
            function escapeHtml(text) {
                return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }

            function updatePromptHighlights() {
                const text = imagePrompt.value;
                let html = escapeHtml(text);
                const foundUnsafe = [];

                // Case-insensitive check for unsafe words
                Object.keys(unsafeMap).forEach(word => {
                    const regex = new RegExp(`\\b${word}\\b`, 'gi');
                    if (regex.test(text)) {
                        html = html.replace(regex, (match) => `<span class="highlight-unsafe">${match}</span>`);
                        foundUnsafe.push({ word: word, suggestion: unsafeMap[word] });
                    }
                });
                
                // Add trailing break for empty line at end to ensure caret visibility
                if (text[text.length - 1] === "\n") {
                    html += " <br>";
                }
                
                promptBackdrop.innerHTML = html;
                updateSafetySuggestions(foundUnsafe);
                // Ensure scroll sync happens after render
                syncPromptScroll();
            }

            function updateSafetySuggestions(foundUnsafe) {
                if (foundUnsafe.length > 0) {
                    safetySuggestionBar.classList.remove('hidden');
                    suggestionContainer.innerHTML = '';
                    
                    // Remove duplicates
                    const uniqueFound = foundUnsafe.filter((v,i,a)=>a.findIndex(t=>(t.word===v.word))===i);

                    uniqueFound.forEach(item => {
                        const btn = document.createElement('button');
                        btn.className = "text-[10px] bg-red-900/30 hover:bg-red-900/60 border border-[var(--accent-red)] px-2 py-1 rounded-none text-white transition-colors";
                        btn.innerHTML = `Replace <b>${item.word}</b> with <b>${item.suggestion}</b>`;
                        btn.onclick = () => {
                             const regex = new RegExp(`\\b${item.word}\\b`, 'gi');
                             imagePrompt.value = imagePrompt.value.replace(regex, item.suggestion);
                             updatePromptHighlights(); // Re-check
                             updateGenerateButton();
                        };
                        suggestionContainer.appendChild(btn);
                    });
                } else {
                    safetySuggestionBar.classList.add('hidden');
                }
            }
            
            function showSafetyAlert(promptText) {
                const foundTriggers = [];
                Object.keys(unsafeMap).forEach(word => {
                    const regex = new RegExp(`\\b${word}\\b`, 'gi');
                    if (regex.test(promptText)) {
                        foundTriggers.push(word);
                    }
                });

                if (foundTriggers.length > 0) {
                    safetyTriggersList.innerHTML = '';
                    foundTriggers.forEach(word => {
                        const li = document.createElement('li');
                        li.textContent = word;
                        safetyTriggersList.appendChild(li);
                    });
                    safetyDiagnostics.classList.remove('hidden');
                } else {
                    safetyDiagnostics.classList.add('hidden');
                }
                
                safetyAlertModal.classList.remove('hidden');
                document.body.classList.add('modal-open');
            }

            // Sync scrolling between textarea and backdrop
            function syncPromptScroll() {
                promptBackdrop.scrollTop = imagePrompt.scrollTop;
            }

            function selectTool(toolId) {
                currentEditMode = toolId;
                
                // Update Toolbar UI
                toolBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === toolId);
                });

                // Update Properties Panel UI
                inpaintControls.classList.add('hidden');
                textControls.classList.add('hidden');
                filtersControls.classList.add('hidden');
                layersControls.classList.add('hidden');
                imageToolControls.classList.add('hidden'); 
                drawControls.classList.add('hidden'); // NEW

                // Reset Canvas Visibility
                fabricCanvasWrapper.classList.remove('hidden'); // Default show fabric (Text/FX)
                maskCanvas.classList.add('hidden'); // Default hide paint mask
                
                // Reset Drawing Mode on Fabric - Do this safely
                if (fabricCanvas) {
                    fabricCanvas.isDrawingMode = false;
                }

                if (toolId === 'inpaint') {
                    // ... existing inpaint logic ...
                    inpaintControls.classList.remove('hidden');
                    fabricCanvasWrapper.classList.add('hidden');
                    
                    if (imageCanvas.classList.contains('active-canvas')) imageCanvas.classList.remove('hidden');
                    maskCanvas.classList.remove('hidden');
                    
                    canvasWrapper.style.transform = 'none';
                    canvasWrapper.style.width = 'auto';
                    canvasWrapper.style.height = 'auto';
                    
                    editInstructionText.textContent = "Inpaint Mode: Draw over the area you want to change.";
                    editInstructionText.parentElement.classList.remove('hidden');

                } else if (toolId === 'draw') { // NEW
                    drawControls.classList.remove('hidden');
                    editInstructionText.textContent = "Draw Studio: Sketch freely on the canvas.";
                    editInstructionText.parentElement.classList.remove('hidden');
                    
                    // FIXED LOGIC: Wait for canvas init before enabling drawing
                    setTimeout(() => {
                        if (!fabricCanvas) initFabricCanvas();
                        else fabricCanvas.calcOffset(); 
                        fitCanvasToScreen();
                        
                        if (fabricCanvas) {
                            fabricCanvas.isDrawingMode = true;
                            updateBrush();
                            fabricCanvas.requestRenderAll();
                        }
                    }, 100); 

                } else if (toolId === 'text') {
                    // ... existing logic ...
                    textControls.classList.remove('hidden');
                    editInstructionText.textContent = "Text Studio: Add, Drag, Resize and Style text.";
                    editInstructionText.parentElement.classList.remove('hidden');
                    initOrUpdateFabric();
                } else if (toolId === 'filters') {
                    filtersControls.classList.remove('hidden');
                    editInstructionText.textContent = "Filters & FX: Apply adjustments or add procedural overlays.";
                    editInstructionText.parentElement.classList.remove('hidden');
                    initOrUpdateFabric();
                } else if (toolId === 'layers') {
                    layersControls.classList.remove('hidden');
                    editInstructionText.textContent = "Layers: Reorder, Select or Delete elements.";
                    editInstructionText.parentElement.classList.remove('hidden');
                    initOrUpdateFabric();
                    renderLayerList(); // Initial render
                } else if (toolId === 'image') { // NEW
                    imageToolControls.classList.remove('hidden');
                    editInstructionText.textContent = "Image Studio: Upload, Transform and Crop images.";
                    editInstructionText.parentElement.classList.remove('hidden');
                    initOrUpdateFabric();
                }
            }
            
            // --- Drawing/Inpaint Tools (Moved up) ---
            function setTool(tool) { 
                currentTool = tool; 
                brushBtn.classList.toggle('btn-primary', tool === 'brush'); 
                eraseBtn.classList.toggle('btn-primary', tool === 'erase'); 
                
                // Re-apply context settings to ensure they stick when switching
                if (maskCtx) {
                    maskCtx.lineCap = 'round';
                    maskCtx.lineJoin = 'round';
                }
            }

            function getCoords(e) {
                const rect = maskCanvas.getBoundingClientRect();
                const scaleX = maskCanvas.width / rect.width; 
                const scaleY = maskCanvas.height / rect.height;
                
                let clientX = e.touches ? e.touches[0].clientX : e.clientX; 
                let clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                // Sanity check for NaNs if rect is 0 (hidden)
                if (!isFinite(scaleX) || !isFinite(scaleY)) return { x: 0, y: 0, scale: 1 };

                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY, scale: scaleX };
            }

            function drawOnCanvas(coords) {
                if (!isDrawing || !maskCtx) return;
                
                maskCtx.lineWidth = brushSize; // Use raw brush size, rely on canvas scaling for visual size
                maskCtx.globalCompositeOperation = (currentTool === 'erase') ? 'destination-out' : 'source-over';
                maskCtx.strokeStyle = 'rgba(13, 153, 255, 0.8)'; // Ensure color is consistent
                
                maskCtx.lineTo(coords.x, coords.y);
                maskCtx.stroke();
                
                // Continuous path for smoother lines
                maskCtx.beginPath();
                maskCtx.moveTo(coords.x, coords.y);
            }

            function handleDrawStart(e) { 
                e.preventDefault(); 
                isDrawing = true; 
                const coords = getCoords(e); 
                
                if (maskCtx) {
                    maskCtx.beginPath(); 
                    maskCtx.lineCap = 'round';
                    maskCtx.lineJoin = 'round';
                    maskCtx.moveTo(coords.x, coords.y); 
                    drawOnCanvas(coords); 
                }
            }
            
            function handleDrawMove(e) { if (!isDrawing) return; e.preventDefault(); drawOnCanvas(getCoords(e)); }
            function handleDrawEnd() { if (!isDrawing) return; isDrawing = false; if(maskCtx) maskCtx.beginPath(); }
            
            function resetMask() { 
                if(maskCtx) {
                    maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height); 
                    // Reset composite after clear
                    maskCtx.globalCompositeOperation = 'source-over';
                }
            }
            
            function getMaskBase64() { return maskCanvas.toDataURL('image/png').split(',')[1]; }
            
            async function doInpainting(prompt) {
                if (!originalImageData) return;
                editModal.classList.add('hidden'); document.body.classList.remove('modal-open');
                await handleImageGeneration(prompt, 'inpainting', getMaskBase64(), inpaintingReferenceData ? inpaintingReferenceData.split(',')[1] : null);
            }
            
            function initOrUpdateFabric() {
                 setTimeout(() => {
                     if (!fabricCanvas) initFabricCanvas();
                     else fabricCanvas.calcOffset(); // Recalculate size
                     fitCanvasToScreen();
                }, 50);
            }

            // --- Update Brush Logic (NEW) ---
            function updateBrush() {
                if (!fabricCanvas) return;
                const type = document.querySelector('.brush-type-btn.active').dataset.type;
                const color = drawColorPicker.value;
                const width = parseInt(drawWidthSlider.value);
                
                if (type === 'pencil') {
                    fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
                } else if (type === 'circle') {
                    fabricCanvas.freeDrawingBrush = new fabric.CircleBrush(fabricCanvas);
                } else if (type === 'spray') {
                    fabricCanvas.freeDrawingBrush = new fabric.SprayBrush(fabricCanvas);
                }
                
                if (fabricCanvas.freeDrawingBrush) {
                    fabricCanvas.freeDrawingBrush.color = color;
                    fabricCanvas.freeDrawingBrush.width = width;
                }
            }

            // ... [Inpainting, Fabric Init, Font Waiting, Text Presets - UNCHANGED] ...
            function setupInpaintingCanvas() {
                if (!originalImageData) return;
                const img = new Image();
                img.onload = () => {
                    imageCanvas.width = maskCanvas.width = img.naturalWidth;
                    imageCanvas.height = maskCanvas.height = img.naturalHeight;
                    
                    // Reset Wrapper Aspect Ratio and Size
                    canvasWrapper.style.aspectRatio = `${img.naturalWidth} / ${img.naturalHeight}`;
                    
                    ctx = imageCanvas.getContext('2d'); 
                    ctx.drawImage(img, 0, 0);
                    
                    maskCtx = maskCanvas.getContext('2d'); 
                    maskCtx.fillStyle = 'rgba(13, 153, 255, 0.8)'; 
                    maskCtx.strokeStyle = 'rgba(13, 153, 255, 0.8)';
                    maskCtx.lineCap = 'round'; 
                    maskCtx.lineJoin = 'round';
                    
                    imageCanvas.classList.remove('hidden'); 
                    imageCanvas.classList.add('active-canvas');
                    
                    resetMask(); 
                    setTool('brush');
                    
                    // Ensure zoom is applied correctly to new canvases
                    applyCanvasZoom();
                }; 
                img.src = originalImageData;
            }
            
            function initFabricCanvas() {
                const el = getEl('textCanvas');
                el.width = imageCanvas.width; el.height = imageCanvas.height;
                fabricCanvas = new fabric.Canvas('textCanvas', { width: imageCanvas.width, height: imageCanvas.height, selection: true, preserveObjectStacking: true });
                if (originalImageData) { fabric.Image.fromURL(originalImageData, (img) => { fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas), { scaleX: fabricCanvas.width / img.width, scaleY: fabricCanvas.height / img.height }); }); }
                
                // EVENTS FOR LAYERS & IMAGE TOOL
                fabricCanvas.on('selection:created', (e) => { 
                    updateTextControlsFromObject(e.selected[0]); 
                    updateImageControlsFromObject(e.selected[0]); // NEW
                    renderLayerList(); 
                });
                fabricCanvas.on('selection:updated', (e) => { 
                    updateTextControlsFromObject(e.selected[0]); 
                    updateImageControlsFromObject(e.selected[0]); // NEW
                    renderLayerList(); 
                });
                fabricCanvas.on('selection:cleared', () => { 
                    imgTransformSection.classList.add('opacity-50', 'pointer-events-none');
                    imgCropSection.classList.add('opacity-50', 'pointer-events-none');
                    renderLayerList(); 
                });
                // When drawing path is added
                fabricCanvas.on('path:created', (e) => {
                     e.path.set({ type: 'path' }); // Ensure type is set
                     renderLayerList();
                });
                fabricCanvas.on('object:added', () => { renderLayerList(); });
                fabricCanvas.on('object:removed', () => { renderLayerList(); });
                fabricCanvas.on('object:modified', () => { renderLayerList(); });
            }
            async function waitForFont(fontFamily) { if (document.fonts) { try { await document.fonts.load(`1em "${fontFamily}"`); } catch (e) {} } return new Promise(resolve => setTimeout(resolve, 50)); }
            async function addTextToCanvas(text = 'Hello', options = {}) {
                if (!fabricCanvas) initFabricCanvas();
                const fontName = options.font || fontFamilySelect.value;
                await waitForFont(fontName);
                const textObj = new fabric.IText(text, { left: fabricCanvas.width / 2, top: fabricCanvas.height / 2, originX: 'center', originY: 'center', fontFamily: fontName, fill: options.fill || textColorPicker.value, fontSize: 40, stroke: options.stroke || textStrokePicker.value, strokeWidth: options.strokeWidth || 0, shadow: options.shadow ? new fabric.Shadow(options.shadow) : null, padding: 5 });
                fabricCanvas.add(textObj); fabricCanvas.setActiveObject(textObj); fabricCanvas.requestRenderAll();
            }
            function applyTextPreset(obj, preset) {
                waitForFont(preset.font).then(() => {
                    obj.set({ fontFamily: preset.font, fill: preset.fill, stroke: preset.stroke, strokeWidth: preset.strokeWidth, shadow: preset.shadow ? new fabric.Shadow(preset.shadow) : null });
                    obj.initDimensions(); obj.setCoords(); fabricCanvas.requestRenderAll();
                });
            }

            // ... [Zoom Logic - UNCHANGED] ...
            function applyCanvasZoom() {
                const fabricContainer = document.querySelector('.canvas-container'); 
                
                // Apply Scale to Fabric Container
                if (fabricContainer) {
                    fabricContainer.style.transformOrigin = 'top left'; 
                    fabricContainer.style.transform = `scale(${currentZoom})`;
                }
                
                // FIXED: Apply Scale to Native Canvases (Inpaint Mode)
                [imageCanvas, maskCanvas].forEach(cvs => {
                    if (cvs) {
                        cvs.style.transformOrigin = 'top left';
                        cvs.style.transform = `scale(${currentZoom})`;
                    }
                });

                // Adjust Wrapper Size to fit scaled content
                if (imageCanvas.width > 0 && imageCanvas.height > 0) {
                    const scaledWidth = imageCanvas.width * currentZoom; 
                    const scaledHeight = imageCanvas.height * currentZoom;
                    canvasWrapper.style.width = `${scaledWidth}px`; 
                    canvasWrapper.style.height = `${scaledHeight}px`;
                }
                
                zoomLevelDisplay.textContent = Math.round(currentZoom * 100) + '%';
            }
            
            function fitCanvasToScreen() {
                if (!imageCanvas.width || !imageCanvas.height) return;
                const vpW = canvasViewport.clientWidth - 80; const vpH = canvasViewport.clientHeight - 80;
                const imgW = imageCanvas.width; const imgH = imageCanvas.height;
                const scaleX = vpW / imgW; const scaleY = vpH / imgH;
                currentZoom = Math.min(scaleX, scaleY); if (currentZoom > 1) currentZoom = 1; 
                applyCanvasZoom();
            }
            function zoomIn() { currentZoom *= 1.2; if (currentZoom > 5) currentZoom = 5; applyCanvasZoom(); }
            function zoomOut() { currentZoom /= 1.2; if (currentZoom < 0.1) currentZoom = 0.1; applyCanvasZoom(); }

            // ... [Control Updates, Fabric Image, LLM - UNCHANGED] ...
            function updateTextControlsFromObject(obj) {
                if (!obj) return;
                fontFamilySelect.value = obj.fontFamily; textColorPicker.value = obj.fill; textStrokePicker.value = obj.stroke || '#000000';
                if (obj.shadow) { text3DToggle.checked = true; text3DControls.classList.remove('opacity-50', 'pointer-events-none'); text3DColorPicker.value = obj.shadow.color; } 
                else { text3DToggle.checked = false; text3DControls.classList.add('opacity-50', 'pointer-events-none'); }
            }
            
            // --- NEW: Image Tool Updates ---
            function updateImageControlsFromObject(obj) {
                if (!obj || (obj.type !== 'image' && obj.type !== 'path')) { // Path usually SVG
                    imgTransformSection.classList.add('opacity-50', 'pointer-events-none');
                    imgCropSection.classList.add('opacity-50', 'pointer-events-none');
                    return;
                }
                
                imgTransformSection.classList.remove('opacity-50', 'pointer-events-none');
                
                // Only allow crop for actual images, not SVGs (paths) easily
                if (obj.type === 'image') {
                    imgCropSection.classList.remove('opacity-50', 'pointer-events-none');
                } else {
                    imgCropSection.classList.add('opacity-50', 'pointer-events-none');
                }
                
                // Sync UI with object
                imgRotateSlider.value = obj.angle % 360;
                imgRotateVal.textContent = Math.round(obj.angle % 360) + '°';
                imgOpacitySlider.value = obj.opacity * 100;
                imgOpacityVal.textContent = Math.round(obj.opacity * 100) + '%';
                
                // Highlight flips if active (Fabric handles scaling for flip, checking if scaleX/Y is negative)
                imgFlipXBtn.classList.toggle('selected', obj.flipX);
                imgFlipYBtn.classList.toggle('selected', obj.flipY);
            }
            
            function getFabricCanvasImage() { return fabricCanvas.toDataURL({ format: 'png', quality: 1, multiplier: 1 }); }
            
            // --- UPDATED llmAction: Now accepts specific image data ---
            const llmAction = async (prompt, simulation, outputTarget = null, specificImageData = null) => {
                startProgressSimulation(simulation);
                let resultText;
                try {
                    let imageDataBase64;
                    if (specificImageData) {
                        imageDataBase64 = specificImageData.split(',')[1];
                    } else {
                        const baseImageInfo = getBaseImageInfo();
                        if (!baseImageInfo) throw new Error("No image to analyze.");
                        imageDataBase64 = baseImageInfo.dataUrl.split(',')[1];
                    }
                    
                    const payload = { contents: [{ parts: [ { text: prompt }, { inlineData: { mimeType: "image/png", data: imageDataBase64 } } ] }] };
                    const response = await fetchWithRetry(textMultimodalApi, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    const result = await response.json(); resultText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!resultText) throw new Error("No text returned from API.");
                    if(outputTarget === 'description') { imageDescription.textContent = resultText; imageDescriptionContainer.classList.remove('hidden'); } 
                    else if(outputTarget === 'story') { showMessageBox("A Spark of Story", resultText, [{ text: "Awesome!", class: "btn-primary"}]); } 
                    else if (outputTarget === 'prompt') { imagePrompt.value = resultText.trim(); }
                } catch (error) { showMessageBox("Error", `Could not complete action: ${error.message}`); } finally { stopProgressSimulation(true); }
            };
            
            const llmTextOnlyAction = async (prompt, systemPrompt, simulation, inlineSpinnerElement = null) => {
                 if (!inlineSpinnerElement) { startProgressSimulation(simulation); } 
                 else { inlineSpinnerElement.classList.remove('hidden'); const btn = inlineSpinnerElement.previousElementSibling; if(btn && btn.tagName === 'BUTTON') btn.disabled = true; }
                 try {
                     const payload = { contents: [{ parts: [{ text: prompt }] }], systemInstruction: { parts: [{ text: systemPrompt }] },};
                     const response = await fetchWithRetry(textMultimodalApi, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                     const result = await response.json(); const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                     if (!text) throw new Error("No text returned from API."); return text.trim();
                 } catch (error) { showMessageBox("Error", `Could not complete action: ${error.message}`); return null; } finally { 
                     if (!inlineSpinnerElement) { stopProgressSimulation(true); } 
                     else { inlineSpinnerElement.classList.add('hidden'); const btn = inlineSpinnerElement.previousElementSibling; if(btn && btn.tagName === 'BUTTON') btn.disabled = false; }
                 }
            }
            
            // ... [Procedural FX - UNCHANGED] ...
            function generateFxSvg(type) {
                const id = Math.random().toString(36).substr(2, 9); let svgContent = '';
                if (type === 'flare') {
                    const colors = [['#ffffff', '#0099ff', 'transparent'], ['#ffffff', '#ffaa00', 'transparent'], ['#ffffff', '#ffffff', 'transparent']];
                    const col = colors[Math.floor(Math.random() * colors.length)];
                    svgContent = `<svg width="600" height="600" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="grad${id}" cx="50%" cy="50%" r="50%" fx="50%" fy="50%"><stop offset="0%" style="stop-color:${col[0]};stop-opacity:1" /><stop offset="40%" style="stop-color:${col[1]};stop-opacity:0.6" /><stop offset="100%" style="stop-color:${col[2]};stop-opacity:0" /></radialGradient><filter id="glow${id}"><feGaussianBlur stdDeviation="10" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><line x1="0" y1="300" x2="600" y2="300" style="stroke:${col[1]};stroke-width:2;opacity:0.5" filter="url(#glow${id})" /><circle cx="300" cy="300" r="150" fill="url(#grad${id})" filter="url(#glow${id})" /><circle cx="300" cy="300" r="20" fill="white" filter="url(#glow${id})" /></svg>`;
                } else if (type === 'sparkle') { svgContent = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"><defs><filter id="blur${id}"><feGaussianBlur in="SourceGraphic" stdDeviation="4" /></filter></defs><g filter="url(#blur${id})"><path d="M100 10 L110 90 L190 100 L110 110 L100 190 L90 110 L10 100 L90 90 Z" fill="white" /></g><path d="M100 20 L105 95 L180 100 L105 105 L100 180 L95 105 L20 100 L95 95 Z" fill="white" /></svg>`; }
                else if (type === 'dust') { let specks = ''; for(let i=0; i<30; i++) { const x = Math.random() * 800; const y = Math.random() * 800; const r = Math.random() * 3; const o = Math.random() * 0.5 + 0.1; specks += `<circle cx="${x}" cy="${y}" r="${r}" fill="white" opacity="${o}" />`; } svgContent = `<svg width="800" height="800" xmlns="http://www.w3.org/2000/svg">${specks}</svg>`; }
                else if (type === 'smoke') { svgContent = `<svg width="500" height="500" xmlns="http://www.w3.org/2000/svg"><defs><filter id="smokeBlur${id}"><feGaussianBlur in="SourceGraphic" stdDeviation="30" /></filter><radialGradient id="smokeGrad${id}"><stop offset="0%" style="stop-color:#cccccc;stop-opacity:0.6" /><stop offset="100%" style="stop-color:#000000;stop-opacity:0" /></radialGradient></defs><g filter="url(#smokeBlur${id})"><circle cx="250" cy="250" r="150" fill="url(#smokeGrad${id})" /><circle cx="300" cy="200" r="100" fill="url(#smokeGrad${id})" /><circle cx="200" cy="300" r="120" fill="url(#smokeGrad${id})" /></g></svg>`; }
                else if (type === 'orb') { const col = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff'][Math.floor(Math.random()*6)]; svgContent = `<svg width="400" height="400" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="orbGrad${id}"><stop offset="0%" style="stop-color:${col};stop-opacity:1" /><stop offset="70%" style="stop-color:${col};stop-opacity:0.2" /><stop offset="100%" style="stop-color:${col};stop-opacity:0" /></radialGradient><filter id="orbBlur${id}"><feGaussianBlur stdDeviation="15" /></filter></defs><circle cx="200" cy="200" r="150" fill="url(#orbGrad${id})" filter="url(#orbBlur${id})" /></svg>`; }
                return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgContent);
            }
            function addEffectToCanvas(type) {
                if (!fabricCanvas) initFabricCanvas();
                const svgUrl = generateFxSvg(type);
                fabric.Image.fromURL(svgUrl, (img) => {
                    img.set({ left: fabricCanvas.width / 2, top: fabricCanvas.height / 2, originX: 'center', originY: 'center', scaleX: 1, scaleY: 1 });
                    if (['flare', 'sparkle', 'orb', 'smoke', 'dust'].includes(type)) { img.globalCompositeOperation = 'screen'; }
                    fabricCanvas.add(img); fabricCanvas.setActiveObject(img); fabricCanvas.requestRenderAll();
                });
            }

            // --- Filter Logic - UNCHANGED ---
            function applyFilters() {
                if (!fabricCanvas) return;
                const bgImg = fabricCanvas.backgroundImage; if (!bgImg) return;
                const filters = [];
                const brightness = parseFloat(filterBrightness.value); if (brightness !== 0) filters.push(new fabric.Image.filters.Brightness({ brightness: brightness }));
                const contrast = parseFloat(filterContrast.value); if (contrast !== 0) filters.push(new fabric.Image.filters.Contrast({ contrast: contrast }));
                const saturation = parseFloat(filterSaturation.value); if (saturation !== 0) filters.push(new fabric.Image.filters.Saturation({ saturation: saturation }));
                // const hue = parseFloat(filterHue.value); if (hue !== 0) filters.push(new fabric.Image.filters.HueRotation({ rotation: hue })); // Removed hue for now based on previous UI feedback
                const blur = parseFloat(filterBlur.value); if (blur > 0) filters.push(new fabric.Image.filters.Blur({ blur: blur }));
                // const noise = parseInt(filterNoise.value); if (noise > 0) filters.push(new fabric.Image.filters.Noise({ noise: noise })); // Removed noise for cleaner UI
                bgImg.filters = filters; bgImg.applyFilters(); fabricCanvas.requestRenderAll();
            }
            
            // --- Event Listeners ---

            // ... [Basic Listeners - UNCHANGED] ...
            clearPromptBtn.addEventListener('click', () => { imagePrompt.value = ''; updatePromptHighlights(); updateGenerateButton(); });
            imagePrompt.addEventListener('input', () => { updateGenerateButton(); updatePromptHighlights(); });
            imagePrompt.addEventListener('scroll', syncPromptScroll); // Sync scroll
            
            refinePromptBtn.addEventListener('click', async () => { if (!imagePrompt.value.trim()) return; const text = await llmTextOnlyAction(imagePrompt.value, "You enhance AI image prompts. Return only the prompt.", 'refine'); if (text) { imagePrompt.value = text; updatePromptHighlights(); updateGenerateButton(); } });
            generateIdeaBtn.addEventListener('click', async () => { const text = await llmTextOnlyAction("A creative, visually-rich prompt idea for an AI image.", "Return only a single prompt idea.", 'idea'); if (text) { imagePrompt.value = text; updatePromptHighlights(); updateGenerateButton(); } });
            uploadAssetBtn.addEventListener('click', () => { if (uploadedImages.length < MAX_ASSETS) { delete fileInput.dataset.replaceId; fileInput.click(); }});
            clearAssetsBtn.addEventListener('click', () => { uploadedImages = []; renderUploadedImages(); updateAssetTagList(); updateGenerateButton(); });
            addAssetTagBtn.addEventListener('click', (e) => { updateAssetTagList(); assetSelectionPopover.classList.toggle('hidden'); e.stopPropagation(); });
            document.addEventListener('click', (e) => { if (!assetSelectionPopover.contains(e.target) && !addAssetTagBtn.contains(e.target)) assetSelectionPopover.classList.add('hidden'); });
            
            // --- Safety Modal Listeners ---
            closeSafetyModal.addEventListener('click', () => { safetyAlertModal.classList.add('hidden'); document.body.classList.remove('modal-open'); });
            acknowledgeSafetyBtn.addEventListener('click', () => { safetyAlertModal.classList.add('hidden'); document.body.classList.remove('modal-open'); });

            // --- Camera Modal Listeners ---
            async function initCamera() {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(t => t.stop());
                }
                try {
                    const constraints = { 
                        video: { 
                            facingMode: currentFacingMode,
                            aspectRatio: { ideal: 1 } // Try to get square if supported, else crop
                        } 
                    };
                    cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                    cameraVideo.srcObject = cameraStream;
                    
                    // Mirror effect only for front camera
                    cameraVideo.style.transform = currentFacingMode === 'user' ? 'scaleX(-1)' : 'none';
                    
                    cameraModal.classList.remove('hidden');
                    resetCameraUI();
                } catch(e) {
                    console.error(e);
                    showMessageBox("Camera Error", "Could not access camera. Please check permissions or device capabilities.");
                }
            }

            function resetCameraUI() {
                cameraVideo.classList.remove('hidden');
                cameraCapturePreview.classList.add('hidden');
                cameraCaptureControls.classList.remove('hidden');
                cameraReviewControls.classList.add('hidden');
                tempCameraCapture = null;
            }

            cameraAssetBtn.addEventListener('click', () => {
                currentFacingMode = 'user'; // Default to front/user
                initCamera();
            });
            
            flipCameraBtn.addEventListener('click', () => {
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                initCamera();
            });
            
            closeCameraBtn.addEventListener('click', () => {
                if(cameraStream) { cameraStream.getTracks().forEach(t => t.stop()); cameraStream = null; }
                cameraModal.classList.add('hidden');
            });
            
            captureCameraBtn.addEventListener('click', () => {
                if(!cameraStream) return;
                
                // Flash effect
                cameraFlash.classList.remove('transition-opacity', 'duration-200');
                cameraFlash.style.opacity = 0.8;
                setTimeout(() => {
                    cameraFlash.classList.add('transition-opacity', 'duration-200');
                    cameraFlash.style.opacity = 0;
                }, 50);

                const canvas = document.createElement('canvas');
                // Use the video's actual render size to ensure WYSIWYG crop
                const rect = cameraVideo.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                
                const ctx = canvas.getContext('2d');
                
                // If mirroring is active, we need to flip the draw context
                if (currentFacingMode === 'user') {
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                }

                // Draw video to canvas (center crop logic handled by object-cover visual, but we need to map that to canvas)
                // Simplification: Draw the video element directly. 
                // Since the video is object-cover in a square div, we simulate that crop:
                const vidW = cameraVideo.videoWidth;
                const vidH = cameraVideo.videoHeight;
                const aspectVideo = vidW / vidH;
                const aspectCanvas = canvas.width / canvas.height; // 1:1
                
                let sx, sy, sWidth, sHeight;
                
                if (aspectVideo > aspectCanvas) {
                    // Video is wider than square
                    sHeight = vidH;
                    sWidth = vidH * aspectCanvas;
                    sx = (vidW - sWidth) / 2;
                    sy = 0;
                } else {
                    // Video is taller than square
                    sWidth = vidW;
                    sHeight = vidW / aspectCanvas;
                    sx = 0;
                    sy = (vidH - sHeight) / 2;
                }
                
                ctx.drawImage(cameraVideo, sx, sy, sWidth, sHeight, 0, 0, canvas.width, canvas.height);
                
                tempCameraCapture = canvas.toDataURL('image/png');
                
                // Switch UI to Review Mode
                cameraCapturePreview.src = tempCameraCapture;
                cameraCapturePreview.classList.remove('hidden');
                cameraVideo.classList.add('hidden');
                
                cameraCaptureControls.classList.add('hidden');
                cameraReviewControls.classList.remove('hidden');
            });

            retakeCameraBtn.addEventListener('click', resetCameraUI);

            saveCameraBtn.addEventListener('click', () => {
                if (!tempCameraCapture) return;

                if (uploadedImages.length < MAX_ASSETS) {
                    uploadedImages.push({ 
                        id: generateId(), 
                        dataUrl: tempCameraCapture, 
                        title: getNextAssetTitle() 
                    });
                    renderUploadedImages();
                    updateAssetTagList();
                    updateGenerateButton();
                    
                    // Small visual feedback instead of alert
                    const originalText = saveCameraBtn.textContent;
                    saveCameraBtn.textContent = "Saved!";
                    saveCameraBtn.classList.add('btn-apply-style'); // Use blue style for feedback
                    setTimeout(() => {
                        saveCameraBtn.textContent = originalText;
                        saveCameraBtn.classList.remove('btn-apply-style');
                        resetCameraUI(); // Go back to capture mode for multiple shots
                    }, 800);
                } else {
                     showMessageBox("Limit Reached", `Max ${MAX_ASSETS} assets.`);
                }
            });

            // ... [File Input Listener - UNCHANGED] ...
            fileInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
                if (files.length === 0) return;
                if (e.target.dataset.replaceId) {
                    const file = files[0]; const reader = new FileReader();
                    reader.onload = (event) => { const dataUrl = event.target.result; const asset = uploadedImages.find(img => img.id === e.target.dataset.replaceId); if (asset) asset.dataUrl = dataUrl; delete e.target.dataset.replaceId; renderUploadedImages(); updateAssetTagList(); updateGenerateButton(); };
                    reader.readAsDataURL(file);
                } else {
                    const spaceAvailable = MAX_ASSETS - uploadedImages.length;
                    if (spaceAvailable <= 0) { showMessageBox("Asset Limit Reached", `Max ${MAX_ASSETS} assets.`); e.target.value = ''; return; }
                    const filesToUpload = files.slice(0, spaceAvailable);
                    const readPromises = filesToUpload.map(file => { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (event) => resolve(event.target.result); reader.onerror = (error) => reject(error); reader.readAsDataURL(file); }); });
                    try { const dataUrls = await Promise.all(readPromises); dataUrls.forEach(dataUrl => { if (uploadedImages.length < MAX_ASSETS) { uploadedImages.push({ id: generateId(), dataUrl, title: getNextAssetTitle() }); } }); renderUploadedImages(); updateAssetTagList(); updateGenerateButton(); } catch (error) { showMessageBox("Upload Error", "Error reading files."); }
                } e.target.value = '';
            });

            // ... [Style/Analyze Listeners - UNCHANGED] ...
            addStyleBtn.addEventListener('click', () => { if (!db || !userId) { showMessageBox("Notice", "Database missing."); return; } tempAnalyzeImages = []; analyzeStyleName.value = ''; analyzeStyleImagePreview.innerHTML = ''; analyzeStyleModal.classList.remove('hidden'); document.body.classList.add('modal-open'); });
            importStyleBtn.addEventListener('click', () => importStyleInput.click()); importStyleInput.addEventListener('change', handleImportStyle); exportStyleBtn.addEventListener('click', handleExportStyle);
            modePromptBtn.addEventListener('click', () => updateStyleMode('prompt')); modeTransferBtn.addEventListener('click', () => updateStyleMode('transfer'));
            analyzeStyleUploadBtn.addEventListener('click', () => analyzeStyleFileInput.click());
            analyzeStyleCancelBtn.addEventListener('click', () => { analyzeStyleModal.classList.add('hidden'); document.body.classList.remove('modal-open'); });
            analyzeStyleFileInput.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/')); if (files.length === 0) return;
                tempAnalyzeImages = []; analyzeStyleImagePreview.innerHTML = ''; e.target.value = ''; 
                const filesToProcess = files.slice(0, 5);
                const readPromises = filesToProcess.map(file => { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (event) => resolve({ dataUrl: event.target.result, file: file }); reader.onerror = (error) => reject(error); reader.readAsDataURL(file); }); });
                try { const images = await Promise.all(readPromises); tempAnalyzeImages = images; images.forEach(img => { const imgEl = document.createElement('img'); imgEl.src = img.dataUrl; imgEl.className = 'w-full h-auto object-cover border border-[var(--border-color)]'; analyzeStyleImagePreview.appendChild(imgEl); }); } catch (error) { showMessageBox("Upload Error", "Error reading files."); }
            });
            analyzeStyleSaveBtn.addEventListener('click', async () => {
                const name = analyzeStyleName.value.trim(); if (!name || tempAnalyzeImages.length === 0) { showMessageBox("Input Required", "Name and images required."); return; }
                analyzeStyleModal.classList.add('hidden'); document.body.classList.remove('modal-open'); startProgressSimulation('style_analysis');
                try {
                    const prompt = "Analyze images. Identify style. Return descriptive keywords.";
                    const parts = [ { text: prompt } ]; tempAnalyzeImages.forEach(img => { parts.push({ inlineData: { mimeType: img.file.type, data: img.dataUrl.split(',')[1] } }); });
                    const payload = { contents: [{ parts }] }; const response = await fetchWithRetry(textMultimodalApi, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    const result = await response.json(); const detectedStyle = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!detectedStyle) throw new Error("Style detection failed.");
                    const docRef = doc(collection(db, `artifacts/${appId}/users/${userId}/custom_styles`)); await setDoc(docRef, { name: name, prompt: detectedStyle.trim(), imageDataUrl: tempAnalyzeImages[0].dataUrl });
                    stopProgressSimulation(true); showMessageBox("Success", `Style '${name}' saved.`);
                } catch (error) { stopProgressSimulation(false); showMessageBox("Error", `Failed to save style: ${error.message}`); }
            });

            // ... [Main Generation Listeners - UPDATED: Explicitly use canvas data for canvas buttons] ...
            generateBtn.addEventListener('click', () => { const isStyleTransfer = (styleMode === 'transfer') && !!selectedStyleKey && !!getBaseImageInfo(); handleImageGeneration(imagePrompt.value.trim(), isStyleTransfer ? 'style_transfer' : 'initial'); });
            
            // FIX: View Button now works correctly with angleTypes
            cameraViewBtn.addEventListener('click', () => { if (originalImageData) { renderAngleOptions(); cameraAngleModal.classList.remove('hidden'); document.body.classList.add('modal-open'); updateViewMode(currentViewMode); } });
            
            // FIX: Describe Button now explicitly passes originalImageData
            describeImageBtn.addEventListener('click', () => originalImageData && llmAction("Describe this image in one paragraph.", 'describe', 'description', originalImageData));
            createStoryBtn.addEventListener('click', () => originalImageData && llmAction("Write a short story based on this image.", 'story', 'story', originalImageData));
            
            downloadBtn.addEventListener('click', () => { if (originalImageData) { const a = document.createElement('a'); a.href = originalImageData; a.download = 'geal-ai-pro.png'; a.click(); }});
            editBtn.addEventListener('click', () => { if (originalImageData) { editModal.classList.remove('hidden'); document.body.classList.add('modal-open'); setTimeout(setupInpaintingCanvas, 50); }});
            cancelAngleBtn.addEventListener('click', () => { cameraAngleModal.classList.add('hidden'); document.body.classList.remove('modal-open'); });
            confirmAngleBtn.addEventListener('click', () => { cameraAngleModal.classList.add('hidden'); document.body.classList.remove('modal-open'); if (currentCameraAnglePrompt) { generateViewBtn.classList.remove('hidden'); } });
            generateViewBtn.addEventListener('click', () => { if (lastGeneratedPrompt || currentCameraAnglePrompt) handleImageGeneration(lastGeneratedPrompt, 'view'); });

            // --- Edit Modal & Toolbar Listeners (NEW) ---
            toolBtns.forEach(btn => {
                btn.addEventListener('click', (e) => selectTool(e.currentTarget.dataset.tool));
            });
            cancelEditBtn.addEventListener('click', () => { editModal.classList.add('hidden'); document.body.classList.remove('modal-open'); });
            
            // Inpaint Listeners
            brushBtn.addEventListener('click', () => setTool('brush')); eraseBtn.addEventListener('click', () => setTool('erase')); resetBtn.addEventListener('click', resetMask);
            brushSizeSlider.addEventListener('input', (e) => { brushSize = parseInt(e.target.value, 10); brushSizeValue.textContent = brushSize; });
            uploadInpaintingRefBtn.addEventListener('click', () => inpaintingRefFileInput.click());
            inpaintingRefFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader(); reader.onload = (event) => { inpaintingReferenceData = event.target.result; inpaintingRefPreview.src = inpaintingReferenceData; inpaintingRefPreview.classList.remove('hidden'); removeInpaintingRefBtn.classList.remove('hidden'); };
                reader.readAsDataURL(file); e.target.value = '';
            });
            removeInpaintingRefBtn.addEventListener('click', () => { inpaintingReferenceData = null; inpaintingRefPreview.src = ''; inpaintingRefPreview.classList.add('hidden'); removeInpaintingRefBtn.classList.add('hidden'); });
            
            // Draw Listeners (NEW)
            brushTypeBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    brushTypeBtns.forEach(b => b.classList.remove('active'));
                    e.currentTarget.classList.add('active');
                    updateBrush();
                });
            });
            drawColorPicker.addEventListener('input', updateBrush);
            drawWidthSlider.addEventListener('input', (e) => {
                drawWidthVal.textContent = e.target.value;
                updateBrush();
            });

            // Text Listeners
            addTextLayerBtn.addEventListener('click', () => addTextToCanvas(textInput.value || 'Hello'));
            fontFamilySelect.addEventListener('change', (e) => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { activeObj.set('fontFamily', e.target.value); fabricCanvas.requestRenderAll(); } });
            textColorPicker.addEventListener('input', (e) => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { activeObj.set('fill', e.target.value); fabricCanvas.requestRenderAll(); } });
            textStrokePicker.addEventListener('input', (e) => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { activeObj.set('stroke', e.target.value); fabricCanvas.requestRenderAll(); } });
            textSizeSlider.addEventListener('input', (e) => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { activeObj.set('fontSize', parseInt(e.target.value)); fabricCanvas.requestRenderAll(); } });
            text3DToggle.addEventListener('change', (e) => {
                const enabled = e.target.checked; text3DControls.classList.toggle('opacity-50', !enabled); text3DControls.classList.toggle('pointer-events-none', !enabled);
                const activeObj = fabricCanvas?.getActiveObject(); if(activeObj) { if(enabled) { activeObj.set('shadow', new fabric.Shadow({ color: text3DColorPicker.value, blur: 0, offsetX: parseInt(text3DDepthSlider.value), offsetY: parseInt(text3DDepthSlider.value) })); } else { activeObj.set('shadow', null); } fabricCanvas.requestRenderAll(); }
            });
            [text3DColorPicker, text3DDepthSlider].forEach(el => { el.addEventListener('input', () => { if (!text3DToggle.checked) return; const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { activeObj.set('shadow', new fabric.Shadow({ color: text3DColorPicker.value, blur: 0, offsetX: parseInt(text3DDepthSlider.value), offsetY: parseInt(text3DDepthSlider.value) })); fabricCanvas.requestRenderAll(); } }); });
            deleteTextBtn.addEventListener('click', () => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { fabricCanvas.remove(activeObj); fabricCanvas.requestRenderAll(); } });

            // Filters & Zoom Listeners
            [filterBrightness, filterContrast, filterSaturation, filterBlur].forEach(input => {
                input.addEventListener('input', (e) => {
                    const id = e.target.id.replace('filter', '').toLowerCase(); const valSpan = document.getElementById(id + 'Val'); if (valSpan) valSpan.textContent = e.target.value; applyFilters();
                }); input.addEventListener('change', applyFilters);
            });
            resetFiltersBtn.addEventListener('click', () => { filterBrightness.value = 0; filterContrast.value = 0; filterSaturation.value = 0; filterBlur.value = 0; ['brightness','contrast','saturation','blur'].forEach(id => getEl(id+'Val').textContent = '0'); applyFilters(); });
            deleteFxBtn.addEventListener('click', () => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { fabricCanvas.remove(activeObj); fabricCanvas.requestRenderAll(); } });
            zoomInBtn.addEventListener('click', zoomIn); zoomOutBtn.addEventListener('click', zoomOut); fitViewBtn.addEventListener('click', fitCanvasToScreen);
            
            // Layer Listeners (NEW)
            layerToFrontBtn.addEventListener('click', () => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { activeObj.bringToFront(); fabricCanvas.requestRenderAll(); renderLayerList(); } });
            layerToBackBtn.addEventListener('click', () => { const activeObj = fabricCanvas?.getActiveObject(); if (activeObj) { activeObj.sendToBack(); fabricCanvas.requestRenderAll(); renderLayerList(); } });

            // --- NEW: Image Tool Listeners ---
            uploadLayerImgBtn.addEventListener('click', () => layerImgInput.click());
            layerImgInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    if (!fabricCanvas) initFabricCanvas();
                    const imgUrl = event.target.result;
                    // Detect SVG vs others
                    if (file.type === 'image/svg+xml') {
                        fabric.loadSVGFromURL(imgUrl, (objects, options) => {
                             const svgObj = fabric.util.groupSVGElements(objects, options);
                             svgObj.set({ left: fabricCanvas.width/2, top: fabricCanvas.height/2, originX: 'center', originY: 'center' });
                             svgObj.scaleToWidth(fabricCanvas.width / 3);
                             svgObj.customName = file.name;
                             fabricCanvas.add(svgObj);
                             fabricCanvas.setActiveObject(svgObj);
                             fabricCanvas.requestRenderAll();
                        });
                    } else {
                        fabric.Image.fromURL(imgUrl, (img) => {
                            img.set({ left: fabricCanvas.width/2, top: fabricCanvas.height/2, originX: 'center', originY: 'center' });
                            img.scaleToWidth(fabricCanvas.width / 2);
                            img.customName = file.name;
                            fabricCanvas.add(img);
                            fabricCanvas.setActiveObject(img);
                            fabricCanvas.requestRenderAll();
                        });
                    }
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            });

            // Transforms
            imgFlipXBtn.addEventListener('click', () => { const obj = fabricCanvas?.getActiveObject(); if(obj) { obj.toggle('flipX'); fabricCanvas.requestRenderAll(); updateImageControlsFromObject(obj); } });
            imgFlipYBtn.addEventListener('click', () => { const obj = fabricCanvas?.getActiveObject(); if(obj) { obj.toggle('flipY'); fabricCanvas.requestRenderAll(); updateImageControlsFromObject(obj); } });
            imgRotateSlider.addEventListener('input', (e) => { const obj = fabricCanvas?.getActiveObject(); if(obj) { obj.rotate(parseFloat(e.target.value)); fabricCanvas.requestRenderAll(); updateImageControlsFromObject(obj); } });
            imgOpacitySlider.addEventListener('input', (e) => { const obj = fabricCanvas?.getActiveObject(); if(obj) { obj.set('opacity', parseFloat(e.target.value)/100); fabricCanvas.requestRenderAll(); updateImageControlsFromObject(obj); } });

            // Crop Logic
            startCropBtn.addEventListener('click', () => {
                 const activeObj = fabricCanvas?.getActiveObject();
                 if (!activeObj || activeObj.type !== 'image') return;
                 
                 isCropping = true;
                 activeCropRect = new fabric.Rect({
                     left: activeObj.left,
                     top: activeObj.top,
                     width: activeObj.getScaledWidth(),
                     height: activeObj.getScaledHeight(),
                     originX: 'center',
                     originY: 'center',
                     fill: 'rgba(0,0,0,0.3)',
                     stroke: '#fff',
                     strokeWidth: 2,
                     strokeDashArray: [5, 5],
                     cornerColor: 'white',
                     cornerSize: 10,
                     transparentCorners: false,
                     lockRotation: true // Crop rect doesn't rotate
                 });
                 
                 // Temp lock original image
                 activeObj.selectable = false;
                 activeObj.evented = false;
                 // Store rotation to reset it momentarily or handle complex logic. 
                 // Simple approach: reset rotation for crop, restore later? No, crop rect should just overlay.
                 // Actually, cropping rotated images in fabric is complex. 
                 // Strategy: We force rotation to 0 for cropping, then user can re-rotate after crop.
                 preCropRotation = activeObj.angle;
                 activeObj.rotate(0);
                 
                 fabricCanvas.add(activeCropRect);
                 fabricCanvas.setActiveObject(activeCropRect);
                 fabricCanvas.requestRenderAll();
                 
                 cropControls.classList.remove('hidden');
                 startCropBtn.classList.add('hidden');
                 
                 // Disable ratio buttons visual state except free
                 cropRatioBtns.forEach(b => b.classList.remove('active'));
                 cropRatioBtns[0].classList.add('active');
            });
            
            cropRatioBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    cropRatioBtns.forEach(b => b.classList.remove('active'));
                    e.currentTarget.classList.add('active');
                    currentCropRatio = e.currentTarget.dataset.ratio;
                    if (activeCropRect && currentCropRatio !== 'free') {
                        const ratio = parseFloat(currentCropRatio);
                        // Adjust rect to match ratio, keeping width or height
                        const w = activeCropRect.width * activeCropRect.scaleX;
                        const h = w / ratio;
                        activeCropRect.set({ height: h / activeCropRect.scaleY });
                        fabricCanvas.requestRenderAll();
                    }
                });
            });

            cancelCropBtn.addEventListener('click', () => {
                 if (!activeCropRect) return;
                 // Restore image state
                 const imgs = fabricCanvas.getObjects().filter(o => o.type === 'image' && !o.selectable);
                 if (imgs.length > 0) {
                     const original = imgs[imgs.length-1]; // Assumption: last locked image is ours
                     original.selectable = true;
                     original.evented = true;
                     original.rotate(preCropRotation);
                     fabricCanvas.setActiveObject(original);
                 }
                 fabricCanvas.remove(activeCropRect);
                 activeCropRect = null;
                 isCropping = false;
                 cropControls.classList.add('hidden');
                 startCropBtn.classList.remove('hidden');
                 fabricCanvas.requestRenderAll();
            });

            applyCropBtn.addEventListener('click', () => {
                if (!activeCropRect) return;
                
                // Find the image being cropped
                const imgs = fabricCanvas.getObjects().filter(o => o.type === 'image' && !o.selectable);
                if (imgs.length === 0) return; // Error state
                const originalImage = imgs[imgs.length-1];

                // Calculate crop coordinates relative to the image
                // 1. Get Crop Rect absolute coords
                const cropLeft = activeCropRect.left - (activeCropRect.getScaledWidth() / 2);
                const cropTop = activeCropRect.top - (activeCropRect.getScaledHeight() / 2);
                const cropWidth = activeCropRect.getScaledWidth();
                const cropHeight = activeCropRect.getScaledHeight();

                // 2. Get Image absolute coords
                const imgLeft = originalImage.left - (originalImage.getScaledWidth() / 2);
                const imgTop = originalImage.top - (originalImage.getScaledHeight() / 2);

                // 3. Relative
                const relativeLeft = cropLeft - imgLeft;
                const relativeTop = cropTop - imgTop;
                
                // 4. Scale back to natural image dimensions
                const scaleX = originalImage.scaleX;
                const scaleY = originalImage.scaleY;
                
                const finalLeft = relativeLeft / scaleX;
                const finalTop = relativeTop / scaleY;
                const finalWidth = cropWidth / scaleX;
                const finalHeight = cropHeight / scaleY;

                // Create cropped data URL
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = finalWidth;
                tempCanvas.height = finalHeight;
                
                // Draw only the cropped part
                // The original image element is available in originalImage._element
                tempCtx.drawImage(
                    originalImage._element, 
                    finalLeft, finalTop, finalWidth, finalHeight, // Source crop
                    0, 0, finalWidth, finalHeight // Dest
                );
                
                const croppedDataUrl = tempCanvas.toDataURL();
                
                // Replace image
                fabric.Image.fromURL(croppedDataUrl, (newImg) => {
                    newImg.set({
                        left: activeCropRect.left,
                        top: activeCropRect.top,
                        originX: 'center',
                        originY: 'center',
                        scaleX: scaleX, // Maintain original visual scale
                        scaleY: scaleY,
                        angle: preCropRotation // Restore rotation
                    });
                    newImg.customName = originalImage.customName || 'Cropped Image';
                    
                    fabricCanvas.remove(originalImage);
                    fabricCanvas.remove(activeCropRect);
                    fabricCanvas.add(newImg);
                    fabricCanvas.setActiveObject(newImg);
                    
                    activeCropRect = null;
                    isCropping = false;
                    cropControls.classList.add('hidden');
                    startCropBtn.classList.remove('hidden');
                    fabricCanvas.requestRenderAll();
                    renderLayerList(); // Update layer list potentially
                });
            });


            // Apply Button
            applyChangesBtn.addEventListener('click', async () => {
                if (currentEditMode === 'inpaint') {
                    const prompt = inpaintingPrompt.value.trim();
                    if (!prompt) { showMessageBox("Confirm Erase", "No prompt entered. Use AI to erase?", [ { text: 'Cancel' }, { text: 'Erase', class: 'btn-primary', action: () => doInpainting("Remove masked object, fill background") } ]); return; }
                    doInpainting(prompt);
                } else if (currentEditMode === 'text' || currentEditMode === 'filters' || currentEditMode === 'layers' || currentEditMode === 'image' || currentEditMode === 'draw') {
                    startProgressSimulation(currentEditMode === 'text' ? 'text_apply' : 'fx_apply');
                    setTimeout(() => {
                        const newImageData = getFabricCanvasImage(); originalImageData = newImageData; generatedImage.src = newImageData; editModal.classList.add('hidden'); document.body.classList.remove('modal-open');
                        generatedImage.onload = () => { stopProgressSimulation(true); showMessageBox("Success", "Edits applied."); };
                    }, 500);
                }
            });

            // ... [Mask Canvas, GEAL Editor Listeners - UNCHANGED] ...
            imageDisplayArea.addEventListener('click', () => { if(originalImageData) { fullScreenImage.src = originalImageData; fullScreenModal.classList.remove('hidden'); document.body.classList.add('modal-open'); }});
            closeFullScreenModal.addEventListener('click', () => { fullScreenModal.classList.add('hidden'); document.body.classList.remove('modal-open'); });
            maskCanvas.addEventListener('mousedown', handleDrawStart); maskCanvas.addEventListener('mousemove', handleDrawMove); maskCanvas.addEventListener('mouseup', handleDrawEnd); maskCanvas.addEventListener('mouseout', handleDrawEnd); maskCanvas.addEventListener('touchstart', handleDrawStart, { passive: false }); maskCanvas.addEventListener('touchmove', handleDrawMove, { passive: false }); maskCanvas.addEventListener('touchend', handleDrawEnd);
            gealEditorBtn.addEventListener('click', () => { if (!db || !userId) { showMessageBox("Notice", "Database missing."); return; } gealEditorStyleName.value = ''; gealEditorStylePrompt.value = ''; gealEditorModal.classList.remove('hidden'); document.body.classList.add('modal-open'); });
            gealEditorCancelBtn.addEventListener('click', () => { gealEditorModal.classList.add('hidden'); document.body.classList.remove('modal-open'); });
            gealEditorSaveBtn.addEventListener('click', async () => {
                const name = gealEditorStyleName.value.trim(); const prompt = gealEditorStylePrompt.value.trim();
                if (!name || !prompt) { showMessageBox("Input Required", "Name and Prompt required."); return; }
                try { const docRef = doc(collection(db, `artifacts/${appId}/users/${userId}/custom_styles`)); await setDoc(docRef, { name: name, prompt: prompt }); gealEditorModal.classList.add('hidden'); document.body.classList.remove('modal-open'); showMessageBox("Success", `Style '${name}' saved.`); } catch (error) { showMessageBox("Error", "Failed to save style."); }
            });
            gealEditorRefineBtn.addEventListener('click', async () => { const prompt = gealEditorStylePrompt.value.trim(); if (!prompt) { showMessageBox("Input Required", "Enter prompt."); return; } const enhancedPrompt = await llmTextOnlyAction(prompt, "You enhance style prompts. Return ONLY enhanced prompt.", 'refine', gealEditorSpinner); if (enhancedPrompt) { gealEditorStylePrompt.value = enhancedPrompt; } });

            // --- RE-ANGLE TOOL JS ---
            function renderReAngleGrid() {
                reAngleGrid.innerHTML = '';
                angleTypes.forEach(angle => {
                    const card = document.createElement('div');
                    card.className = 'angle-card';
                    card.innerHTML = `
                        <div class="angle-card-header">${angle.name}</div>
                        <div class="relative w-full aspect-square bg-[var(--bg-surface)]">
                            <img id="angle-img-${angle.id}" class="angle-preview hidden" alt="${angle.name}">
                            <div id="angle-loader-${angle.id}" class="absolute inset-0 flex flex-col items-center justify-center bg-black/50 hidden">
                                <div class="simple-spinner mb-2"></div>
                                <span id="angle-timer-${angle.id}" class="text-xs text-white font-mono">0.0s</span>
                            </div>
                        </div>
                        <div class="angle-card-actions">
                            <button class="btn btn-primary flex-1 text-[10px] p-2 min-h-0 h-8 flex items-center justify-center" onclick="window.generateAngle('${angle.id}')">Generate</button>
                            <a id="angle-dl-${angle.id}" class="btn flex-1 text-[10px] p-2 min-h-0 h-8 pointer-events-none opacity-50 flex items-center justify-center" download="angle-${angle.id}.png" title="Download">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/>
                                </svg>
                            </a>
                        </div>
                    `;
                    reAngleGrid.appendChild(card);
                });
            }

            // Expose function globally for HTML onclick
            window.generateAngle = async (angleId) => {
                if (!reAngleSourceImage) {
                    showMessageBox("Source Required", "Please select or upload a source image first.");
                    return;
                }
                
                const angleData = angleTypes.find(a => a.id === angleId);
                const imgEl = getEl(`angle-img-${angleId}`);
                const dlBtn = getEl(`angle-dl-${angleId}`);
                const loader = getEl(`angle-loader-${angleId}`);
                const timerEl = getEl(`angle-timer-${angleId}`);
                
                // UI Loading State
                loader.classList.remove('hidden');
                imgEl.classList.add('hidden');
                dlBtn.classList.add('pointer-events-none', 'opacity-50');
                
                // Start Timer
                let startTime = Date.now();
                if(timerEl) timerEl.textContent = "0.0s";
                const timerInterval = setInterval(() => {
                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    if(timerEl) timerEl.textContent = `${elapsed}s`;
                }, 100);
                
                // Construct Prompt based on Mode
                const basePrompt = imagePrompt.value.trim() || "the subject";
                let transformPrompt = "";
                
                // UPDATED: Added Robust Negative Safety Prompt
                const negativeSafety = `
                NEGATIVE PROMPT / STRICTLY AVOID:
                Distorted anatomy, melting face, extra fingers, missing limbs, bad hands, blurry, low quality, pixelated, watermark, text, signature, bad perspective, impossible geometry, mutation, deformed, ugly, disfigured, gross, weird eyes, double heads, fused bodies, mismatched eyes, cross-eyed, lowres, polaroid, grainy.`;

                if (currentReAngleMode === 'subject') {
                    // Subject Rotation Logic - Focus on rotating the OBJECT, keeping camera/bg static
                    transformPrompt = `TASK: Rotate ONLY the Main Subject to ${angleData.name}.
                    TARGET ORIENTATION: ${angleData.prompt}
                    
                    STRICT INSTRUCTIONS:
                    1. ANATOMY & FACE: Preserve facial identity, eyes, and body proportions perfectly. NO distortion, NO melting.
                    2. CAMERA FIXED: Keep the background scenery and camera position EXACTLY as they are.
                    3. ROTATE OBJECT: Spin the character/object in 3D space to the target angle.
                    4. ISOLATED ACTION: Do NOT rotate the world, only the subject.
                    5. QUALITY: High fidelity, 8k resolution, sharp focus.
                    
                    ${negativeSafety}
                    
                    CONTEXT: ${basePrompt}`;
                } else {
                    // Camera (Scene) Rotation Logic - Focus on moving the CAMERA, changing entire perspective
                    transformPrompt = `TASK: Move the Virtual Camera to ${angleData.name}.
                    TARGET PERSPECTIVE: ${angleData.prompt}
                    
                    STRICT INSTRUCTIONS:
                    1. PRESERVE SUBJECT: Keep the subject's face and body proportional and undistorted. Fix eyes and hands.
                    2. PERSPECTIVE SHIFT: Re-render the ENTIRE SCENE from the new viewpoint.
                    3. BACKGROUND: The floor and horizon line MUST change to match the new camera angle.
                    4. CONSISTENCY: Keep the same art style, identity, and general setting.
                    5. QUALITY: Photorealistic, no blur, perfect anatomy.
                    
                    ${negativeSafety}
                    
                    CONTEXT: ${basePrompt}`;
                }

                try {
                    const parts = [
                        { text: transformPrompt },
                        { inlineData: { mimeType: "image/png", data: reAngleSourceImage.split(',')[1] } }
                    ];
                    
                    const payload = { 
                        contents: [{ parts }], 
                        generationConfig: { responseModalities: ['IMAGE'] } 
                    };
                    
                    const response = await fetchWithRetry(imageToImageApi, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(payload) 
                    });
                    
                    const result = await response.json();
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                    
                    if (!base64Data) throw new Error("No image generated.");
                    
                    const url = `data:image/png;base64,${base64Data}`;
                    imgEl.src = url;
                    imgEl.classList.remove('hidden');
                    
                    dlBtn.href = url;
                    dlBtn.classList.remove('pointer-events-none', 'opacity-50');
                    
                    checkDownloadAllState();

                } catch (error) {
                    console.error(error);
                    showMessageBox("Generation Failed", "Could not generate angle.");
                } finally {
                    clearInterval(timerInterval);
                    loader.classList.add('hidden');
                }
            };
            
            function checkDownloadAllState() {
                const generatedCount = reAngleGrid.querySelectorAll('img.angle-preview:not(.hidden)').length;
                reAngleDownloadAllBtn.disabled = generatedCount === 0;
            }
            
            // Re-Angle Mode Toggle Listeners
            const reAngleModeBtns = document.querySelectorAll('.re-angle-mode-btn');
            reAngleModeBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Update State
                    currentReAngleMode = e.currentTarget.dataset.mode;
                    
                    // Update UI
                    reAngleModeBtns.forEach(b => {
                        b.classList.remove('active', 'text-[var(--accent-blue)]', 'bg-[var(--tool-active)]');
                        b.classList.add('text-[var(--text-secondary)]');
                        // Find the span inside to reset weight
                        b.querySelector('span').classList.remove('text-[var(--text-primary)]');
                    });
                    
                    const activeBtn = e.currentTarget;
                    activeBtn.classList.add('active', 'text-[var(--accent-blue)]', 'bg-[var(--tool-active)]');
                    activeBtn.classList.remove('text-[var(--text-secondary)]');
                    activeBtn.querySelector('span').classList.add('text-[var(--text-primary)]');
                });
            });

            function updateReAngleAssets() {
                reAngleAssetSelect.innerHTML = '<option value="">Select an asset...</option>';
                uploadedImages.forEach(img => {
                    const opt = document.createElement('option');
                    opt.value = img.id;
                    opt.textContent = img.title;
                    reAngleAssetSelect.appendChild(opt);
                });
            }

            function setReAngleSource(sourceType) {
                // UI Toggle
                reAngleSourceBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.source === sourceType);
                });
                
                // Content Toggle
                sourceCanvasArea.classList.toggle('hidden', sourceType !== 'canvas');
                sourceAssetsArea.classList.toggle('hidden', sourceType !== 'assets');
                sourceUploadArea.classList.toggle('hidden', sourceType !== 'upload');
                
                // Reset State
                reAngleSourceImage = null;
                currentReAngleSource = sourceType;
                
                if (sourceType === 'canvas') {
                    if (originalImageData) {
                        reAnglePreviewCanvas.src = originalImageData;
                        reAnglePreviewCanvas.classList.remove('hidden');
                        reAngleNoCanvasMsg.classList.add('hidden');
                        reAngleSourceImage = originalImageData;
                    } else {
                        reAnglePreviewCanvas.classList.add('hidden');
                        reAngleNoCanvasMsg.classList.remove('hidden');
                    }
                } else if (sourceType === 'assets') {
                    reAnglePreviewAsset.classList.add('hidden');
                    reAnglePreviewAsset.src = '';
                    reAngleAssetSelect.value = '';
                    updateReAngleAssets();
                } else if (sourceType === 'upload') {
                     // Keep existing uploaded image if exists
                     if(reAnglePreviewUpload.src && !reAnglePreviewUpload.classList.contains('hidden')) {
                         reAngleSourceImage = reAnglePreviewUpload.src;
                     }
                }
            }

            reAngleToolBtn.addEventListener('click', () => {
                reAngleModal.classList.remove('hidden');
                renderReAngleGrid();
                setReAngleSource('canvas'); // Default to canvas
            });

            closeReAngleBtn.addEventListener('click', () => {
                reAngleModal.classList.add('hidden');
            });
            
            reAngleSourceBtns.forEach(btn => {
                btn.addEventListener('click', (e) => setReAngleSource(e.target.dataset.source));
            });

            reAngleAssetSelect.addEventListener('change', (e) => {
                const assetId = e.target.value;
                const asset = uploadedImages.find(img => img.id === assetId);
                if (asset) {
                    reAnglePreviewAsset.src = asset.dataUrl;
                    reAnglePreviewAsset.classList.remove('hidden');
                    reAngleSourceImage = asset.dataUrl;
                } else {
                    reAnglePreviewAsset.classList.add('hidden');
                    reAngleSourceImage = null;
                }
            });

            reAngleUploadBtn.addEventListener('click', () => reAngleUploadInput.click());
            reAngleUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        reAnglePreviewUpload.src = evt.target.result;
                        reAnglePreviewUpload.classList.remove('hidden');
                        reAngleSourceImage = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = '';
            });

            reAngleDownloadAllBtn.addEventListener('click', () => {
                const links = reAngleGrid.querySelectorAll('a.btn:not(.pointer-events-none)');
                links.forEach((link, index) => {
                    setTimeout(() => {
                        link.click();
                    }, index * 300); // Stagger downloads
                });
            });

            reAngleGenerateAllBtn.addEventListener('click', async () => {
                if (!reAngleSourceImage) {
                    showMessageBox("Source Required", "Please select a source image.");
                    return;
                }
                
                reAngleGenerateAllBtn.disabled = true;
                const originalText = reAngleGenerateAllBtn.textContent;
                reAngleGenerateAllBtn.textContent = "Processing...";
                
                for (const angle of angleTypes) {
                    await window.generateAngle(angle.id);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                reAngleGenerateAllBtn.disabled = false;
                reAngleGenerateAllBtn.textContent = originalText;
            });

            // --- DESCRIBE STUDIO LOGIC (NEW) ---
            describeToolBtn.addEventListener('click', () => { describeModal.classList.remove('hidden'); renderDescribeQueue(); });
            closeDescribeBtn.addEventListener('click', () => { describeModal.classList.add('hidden'); });
            describeUploadBtn.addEventListener('click', () => describeFileInput.click());
            
            describeFileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
                handleDescribeFiles(files);
                e.target.value = '';
            });
            
            describeFromCanvasBtn.addEventListener('click', () => {
                if (!originalImageData) {
                    showMessageBox("Canvas Empty", "No image on canvas.");
                    return;
                }
                // Convert dataURL to blob/file simulation for consistency
                const id = generateId();
                describeQueue.push({ id: id, dataUrl: originalImageData, status: 'pending', desc: null, prompt: null });
                renderDescribeQueue();
            });
            
            function handleDescribeFiles(files) {
                if (files.length === 0) return;
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const id = generateId();
                        describeQueue.push({ id: id, dataUrl: evt.target.result, status: 'pending', desc: null, prompt: null });
                        renderDescribeQueue();
                    };
                    reader.readAsDataURL(file);
                });
            }
            
            function renderDescribeQueue() {
                if (describeQueue.length === 0) {
                    describeEmptyMsg.classList.remove('hidden');
                    describeGrid.innerHTML = ''; describeGrid.appendChild(describeEmptyMsg);
                    startDescribeBtn.disabled = true; downloadAllDescriptionsBtn.disabled = true;
                    return;
                }
                describeEmptyMsg.classList.add('hidden'); describeGrid.innerHTML = ''; describeGrid.appendChild(describeEmptyMsg);
                
                let pendingCount = 0; let doneCount = 0;
                describeQueue.forEach(item => {
                    if (item.status === 'pending') pendingCount++;
                    if (item.status === 'done') doneCount++;
                    
                    const card = document.createElement('div'); card.className = 'enhance-card';
                    
                    let overlayContent = '';
                    if (item.status === 'processing') overlayContent = `<div class="enhance-overlay"><div class="simple-spinner mb-2"></div><span class="text-xs text-white">Analyzing...</span></div>`;
                    
                    let actions = '';
                    if (item.status === 'done') {
                        actions = `<div class="absolute bottom-0 left-0 right-0 p-1 bg-black/80 flex flex-col gap-1">
                            <div class="flex gap-1">
                                <button class="text-[9px] bg-[var(--bg-surface)] text-[var(--text-primary)] border border-[var(--border-color)] px-1 py-1 flex-1 hover:bg-[var(--tool-hover)] uppercase tracking-wider" onclick="window.viewDescription('${item.id}')">Description</button>
                                <button class="text-[9px] bg-[var(--bg-surface)] text-[var(--text-primary)] border border-[var(--border-color)] px-1 py-1 flex-1 hover:bg-[var(--tool-hover)] uppercase tracking-wider" onclick="window.viewResultPrompt('${item.id}')">Prompt</button>
                            </div>
                            <button class="text-[9px] bg-[var(--accent-blue)] text-white w-full py-1 hover:opacity-80 uppercase tracking-widest" onclick="window.downloadSingleDescription('${item.id}')">Download</button>
                        </div>`;
                    } else if (item.status === 'pending') {
                        actions = `<button class="absolute top-1 right-1 bg-red-600 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs hover:bg-red-700 z-20" onclick="window.removeDescribeItem('${item.id}')">&times;</button>`;
                    }

                    card.innerHTML = `<img src="${item.dataUrl}" class="enhance-thumb ${item.status === 'processing' ? 'opacity-50' : ''}">${overlayContent}${actions}`;
                    describeGrid.appendChild(card);
                });
                
                startDescribeBtn.disabled = pendingCount === 0;
                downloadAllDescriptionsBtn.disabled = doneCount === 0;
            }
            
            window.removeDescribeItem = (id) => { describeQueue = describeQueue.filter(i => i.id !== id); renderDescribeQueue(); };
            
            window.viewDescription = (id) => {
                const item = describeQueue.find(i => i.id === id); if(!item) return;
                resultViewTitle.textContent = "Image Description";
                resultViewImage.src = item.dataUrl;
                resultViewDescription.textContent = item.desc || "No description available.";
                resultViewPrompt.textContent = item.prompt || "No prompt available.";
                
                // Hide prompt section if just viewing description? No, show both for context.
                resultViewModal.classList.remove('hidden'); document.body.classList.add('modal-open');
                
                useResultPromptBtn.onclick = () => {
                    imagePrompt.value = item.prompt; describeModal.classList.add('hidden'); resultViewModal.classList.add('hidden'); document.body.classList.remove('modal-open'); updateGenerateButton(); updatePromptHighlights();
                };
            };
            
            window.viewResultPrompt = (id) => { window.viewDescription(id); }; // Same modal, shows both
            
            window.downloadSingleDescription = (id) => {
                const item = describeQueue.find(i => i.id === id); if(!item) return;
                const textContent = `IMAGE ANALYSIS RESULT\n\n[DESCRIPTION]\n${item.desc}\n\n[SAFE GENERATION PROMPT]\n${item.prompt}`;
                const blob = new Blob([textContent], { type: 'text/plain' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `analysis-${id}.txt`; a.click();
            };
            
            downloadAllDescriptionsBtn.addEventListener('click', () => {
                const doneItems = describeQueue.filter(i => i.status === 'done');
                if (doneItems.length === 0) return;
                // Simple concatenated text file for simplicity
                let combinedText = "GEAL AI PRO - BATCH ANALYSIS RESULTS\n====================================\n\n";
                doneItems.forEach((item, index) => {
                    combinedText += `IMAGE #${index+1} (ID: ${item.id})\n---------------------------\n[DESCRIPTION]\n${item.desc}\n\n[PROMPT]\n${item.prompt}\n\n====================================\n\n`;
                });
                const blob = new Blob([combinedText], { type: 'text/plain' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `batch-analysis-${Date.now()}.txt`; a.click();
            });
            
            closeResultViewBtn.addEventListener('click', () => { resultViewModal.classList.add('hidden'); }); // Keep describe modal open behind it
            copyResultPromptBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(resultViewPrompt.textContent).then(() => {
                    const originalText = copyResultPromptBtn.textContent; copyResultPromptBtn.textContent = "Copied!"; setTimeout(() => copyResultPromptBtn.textContent = originalText, 1500);
                });
            });

            startDescribeBtn.addEventListener('click', async () => {
                const pendingItems = describeQueue.filter(i => i.status === 'pending');
                if (pendingItems.length === 0) return;
                
                startDescribeBtn.disabled = true;
                startProgressSimulation('describe_batch'); // Global loader just to show activity
                
                for (const item of pendingItems) {
                    item.status = 'processing';
                    renderDescribeQueue();
                    
                    try {
                        const prompt = "Analyze this image. Provide two distinct sections:\n\n1. **DESCRIPTION**: A detailed visual description.\n2. **PROMPT**: A safe, high-quality text-to-image prompt to recreate this image style and subject. Avoid unsafe terms.\n\nEnsure strict separation with the headers **DESCRIPTION** and **PROMPT**.";
                        
                        const payload = { contents: [{ parts: [ { text: prompt }, { inlineData: { mimeType: "image/png", data: item.dataUrl.split(',')[1] } } ] }] };
                        const response = await fetchWithRetry(textMultimodalApi, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        const result = await response.json(); 
                        const fullText = result.candidates?.[0]?.content?.parts?.[0]?.text || "";
                        
                        // Parse
                        let desc = "Analysis failed.";
                        let genPrompt = "Analysis failed.";
                        
                        const descMatch = fullText.match(/\*\*DESCRIPTION\*\*[\s\S]*?(?=\*\*PROMPT\*\*|$)/i);
                        if (descMatch) desc = descMatch[0].replace(/\*\*DESCRIPTION\*\*/i, '').trim();
                        
                        const promptMatch = fullText.match(/\*\*PROMPT\*\*[\s\S]*/i);
                        if (promptMatch) genPrompt = promptMatch[0].replace(/\*\*PROMPT\*\*/i, '').trim();
                        
                        item.desc = desc;
                        item.prompt = genPrompt;
                        item.status = 'done';
                        
                        // Artificial delay for animation feel
                        await new Promise(r => setTimeout(r, 1000));
                        
                    } catch (e) {
                        console.error(e);
                        item.status = 'error';
                    }
                    renderDescribeQueue();
                }
                
                stopProgressSimulation(true);
                startDescribeBtn.disabled = false;
            });

            // --- ENHANCE STUDIO LOGIC (NEW) ---
            enhanceToolBtn.addEventListener('click', () => {
                enhanceModal.classList.remove('hidden');
            });
            
            closeEnhanceBtn.addEventListener('click', () => {
                enhanceModal.classList.add('hidden');
            });
            
            enhanceUploadBtn.addEventListener('click', () => enhanceFileInput.click());
            
            enhanceFileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
                if (files.length === 0) return;
                
                const remainingSlots = MAX_ENHANCE_BATCH - enhanceQueue.length;
                const toAdd = files.slice(0, remainingSlots);
                
                if (toAdd.length < files.length) {
                    showMessageBox("Batch Limit", `Max ${MAX_ENHANCE_BATCH} images allowed.`);
                }
                
                toAdd.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const id = generateId();
                        enhanceQueue.push({
                            id: id,
                            file: file,
                            originalData: evt.target.result,
                            status: 'pending', // pending, processing, done
                            resultData: null
                        });
                        renderEnhanceQueue();
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            });
            
            function renderEnhanceQueue() {
                if (enhanceQueue.length === 0) {
                    enhanceEmptyMsg.classList.remove('hidden');
                    enhanceGrid.innerHTML = '';
                    enhanceGrid.appendChild(enhanceEmptyMsg);
                    startEnhanceBtn.disabled = true;
                    enhanceTotalEst.classList.add('hidden');
                    return;
                }
                
                enhanceEmptyMsg.classList.add('hidden');
                enhanceGrid.innerHTML = ''; // Clear but keep msg ref if needed (msg is inside grid in HTML structure, so re-add logic needed or structure change. Let's just rebuild)
                
                // Re-add empty msg hidden
                enhanceGrid.appendChild(enhanceEmptyMsg);
                
                let pendingCount = 0;
                
                enhanceQueue.forEach(item => {
                    if (item.status === 'pending') pendingCount++;
                    
                    const card = document.createElement('div');
                    card.className = 'enhance-card';
                    
                    // HTML Construction based on status
                    let statusOverlay = '';
                    let actionButtons = '';

                    if (item.status === 'pending') {
                        actionButtons = `<button class="absolute top-1 right-1 bg-red-600 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs hover:bg-red-700" onclick="removeEnhanceItem('${item.id}')">&times;</button>`;
                    } else if (item.status === 'processing') {
                        statusOverlay = `
                            <div class="enhance-overlay">
                                <div class="simple-spinner mb-2"></div>
                                <span class="text-xs text-white font-mono" id="timer-${item.id}">0.0s</span>
                             </div>
                        `;
                    } else if (item.status === 'error') {
                        // RED FILTER AND CAUTION TEXT FOR ERRORS
                        statusOverlay = `
                            <div class="enhance-overlay !bg-red-900/80 backdrop-blur-sm">
                                <span class="text-2xl mb-1">⚠️</span>
                                <span class="text-[10px] font-bold text-white uppercase tracking-widest leading-tight text-center">Caution<br>Process Failed</span>
                                <button class="mt-2 text-[9px] bg-black/50 hover:bg-black/80 text-white px-2 py-1 border border-white/20" onclick="removeEnhanceItem('${item.id}')">Dismiss</button>
                             </div>
                        `;
                    } else if (item.status === 'done') {
                        actionButtons = `
                            <div class="absolute bottom-0 left-0 right-0 p-1 bg-black/80 flex justify-between items-center gap-1">
                                <button class="text-[10px] bg-[var(--bg-surface)] text-[var(--text-primary)] border border-[var(--border-color)] px-2 py-1 flex-1 hover:bg-[var(--tool-hover)] uppercase tracking-wider" onclick="window.viewComparison('${item.id}')">Compare</button>
                                <a href="${item.resultData}" download="enhanced-${item.id}.png" class="text-xs bg-[var(--accent-blue)] text-white w-6 h-6 flex items-center justify-center rounded hover:opacity-80">↓</a>
                             </div>
                        `;
                    }

                    card.innerHTML = `
                        <img src="${item.resultData || item.originalData}" class="enhance-thumb ${item.status === 'processing' || item.status === 'error' ? 'opacity-50' : ''}">
                        ${statusOverlay}
                        ${actionButtons}
                    `;
                    enhanceGrid.appendChild(card);
                });
                
                startEnhanceBtn.disabled = pendingCount === 0;
                
                // Calc Estimate (approx 8s per image)
                if (pendingCount > 0) {
                    enhanceTotalEst.textContent = `EST: ~${pendingCount * 8}s`;
                    enhanceTotalEst.classList.remove('hidden');
                } else {
                    enhanceTotalEst.classList.add('hidden');
                }
            }
            
            // Global function for onclick removal
            window.removeEnhanceItem = (id) => {
                enhanceQueue = enhanceQueue.filter(i => i.id !== id);
                renderEnhanceQueue();
            };

            // Global function for Comparison
            window.viewComparison = (id) => {
                const item = enhanceQueue.find(i => i.id === id);
                if (!item || !item.resultData) return;

                compareOriginalImg.src = item.originalData;
                compareResultImg.src = item.resultData;
                
                // Reset slider
                compareSlider.value = 50;
                compareResultImg.style.clipPath = `polygon(0 0, 50% 0, 50% 100%, 0 100%)`;
                compareSliderLine.style.left = `50%`;
                
                comparisonModal.classList.remove('hidden');
                document.body.classList.add('modal-open');
            };

            // Slider Logic for Comparison Modal
            if(compareSlider) {
                compareSlider.addEventListener('input', (e) => {
                    const val = e.target.value;
                    compareResultImg.style.clipPath = `polygon(0 0, ${val}% 0, ${val}% 100%, 0 100%)`;
                    compareSliderLine.style.left = `${val}%`;
                });
            }

            [closeComparisonBtn, closeComparisonActionBtn].forEach(btn => {
                if(btn) {
                    btn.addEventListener('click', () => {
                        comparisonModal.classList.add('hidden');
                        // Don't remove modal-open if another modal (enhance) is behind it
                        if(enhanceModal.classList.contains('hidden')) {
                            document.body.classList.remove('modal-open');
                        }
                    });
                }
            });
            
            startEnhanceBtn.addEventListener('click', async () => {
                const pendingItems = enhanceQueue.filter(i => i.status === 'pending');
                if (pendingItems.length === 0) return;
                
                startEnhanceBtn.disabled = true;
                
                // Process sequentially
                for (const item of pendingItems) {
                    item.status = 'processing';
                    renderEnhanceQueue();
                    
                    const timerEl = document.getElementById(`timer-${item.id}`);
                    let startTime = Date.now();
                    const timerInterval = setInterval(() => {
                        if(timerEl) timerEl.textContent = ((Date.now() - startTime) / 1000).toFixed(1) + 's';
                    }, 100);
                    
                    try {
                        // specialized prompt for enhancement
                        const prompt = "High-fidelity Image Enhancement. Upscale to 8k resolution. Fix facial features, eyes, and skin texture. Correct anatomy and proportions. Sharpen all details, remove blur, denoize, correct lighting. Keep original composition and colors exactly same. Photorealistic output.";
                        
                        // Reuse helper (simulated via existing API logic)
                        const enhancedBase64Url = await generateImageFromPrompt(prompt, item.originalData);
                        
                        item.resultData = enhancedBase64Url;
                        item.status = 'done';
                    } catch (e) {
                        console.error(e);
                        item.status = 'error'; // Set specific error status
                    } finally {
                        clearInterval(timerInterval);
                        renderEnhanceQueue();
                    }
                }
                
                startEnhanceBtn.disabled = false;
            });
            
            // Helper to generate without affecting main canvas state
            async function generateImageFromPrompt(prompt, sourceDataUrl) {
                const parts = [
                    { text: prompt },
                    { inlineData: { mimeType: "image/png", data: sourceDataUrl.split(',')[1] } }
                ];
                
                const payload = { 
                    contents: [{ parts }], 
                    generationConfig: { responseModalities: ['IMAGE'] } 
                };
                
                const response = await fetchWithRetry(imageToImageApi, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(payload) 
                });
                
                const result = await response.json();
                const base64 = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                
                if (!base64) throw new Error("Generation failed");
                return `data:image/png;base64,${base64}`;
            }

            // --- Initial Setup ---
            canvasAspectRatioWrapper.style.paddingBottom = '100%'; renderStyles(); renderUploadedImages(); updateAssetTagList(); updateStyleMode('prompt'); updateViewMode('rotate_image'); renderGealEditorTweaks(); renderTextPresets(); renderFxLibrary(); loadUsageStats();
            selectTool('inpaint'); // Default tool
            updatePromptHighlights(); // Initial highlight run
        });
    </script>
</body>
</html>